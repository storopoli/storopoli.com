<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com https://www.youtube.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://storopoli.com name=base><title>
Jose Storopoli, PhD • Randomness in computation: sprinkle a little bit of randomness, and voilà!</title><link href=https://storopoli.com/favicon.svg rel=icon type=image/png><link title="Jose Storopoli, PhD - Atom Feed" href=https://storopoli.com/atom.xml rel=alternate type=application/atom+xml><link href="https://storopoli.com/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://storopoli.com/main.css?h=6b1dda977391dad0c76e" rel=stylesheet><link href="https://storopoli.com/extra.css?h=33c2dfb527f758787862" rel=stylesheet><link href="https://storopoli.com/skins/teal.css?h=bd19e558a52d678a50de" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Personal website of Jose Storopoli, PhD" name=description><meta content="Personal website of Jose Storopoli, PhD" property=og:description><meta content="Randomness in computation: sprinkle a little bit of randomness, and voilà!" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://storopoli.com/blog/randomness/ property=og:url><meta content="Jose Storopoli, PhD" property=og:site_name><noscript><link href=https://storopoli.com/no_js.css rel=stylesheet></noscript><script src=https://storopoli.com/js/initializeTheme.min.js></script><script defer src=https://storopoli.com/js/themeSwitcher.min.js></script><body><header><nav class=navbar><div class=nav-title><a class=home-title href=https://storopoli.com>Jose Storopoli, PhD</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://storopoli.com/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://storopoli.com/tags/>tags </a><li class=menu-icons-container><ul class=menu-icons-group><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content><main><article><h1 class=article-title>Randomness in computation: sprinkle a little bit of randomness, and voilà!</h1><ul class=meta><span class="hidden p-author h-card"> <a title="Jose Storopoli, PhD" class=u-url href=https://storopoli.com rel=author>Jose Storopoli, PhD</a> </span><li>7th Apr 2025<li title="2641 words"><span aria-hidden=true class=separator>•</span>14 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a href=https://storopoli.com/tags/math/>math</a>, <li class=tag><a href=https://storopoli.com/tags/probability/>probability</a>, <li class=tag><a href=https://storopoli.com/tags/programming/>programming</a>, <li class=tag><a href=https://storopoli.com/tags/haskell/>haskell</a></ul><div class=toc-container><h3>Table of Contents</h3><ul><li><a href=https://storopoli.com/blog/randomness/#chebyshev-s-inequality>Chebyshev’s Inequality</a><li><a href=https://storopoli.com/blog/randomness/#randomized-median>Randomized Median</a> <ul><li><a href=https://storopoli.com/blog/randomness/#why-these-guarantees-work>Why These Guarantees Work</a></ul><li><a href=https://storopoli.com/blog/randomness/#haskell-implementation>Haskell Implementation</a><li><a href=https://storopoli.com/blog/randomness/#results>Results</a><li><a href=https://storopoli.com/blog/randomness/#conclusion>Conclusion</a><li><a href=https://storopoli.com/blog/randomness/#references>References</a></ul></div><section class=body><noscript><div class="admonition warning"><div class="admonition-icon admonition-icon-warning"></div><div class=admonition-content><strong class=admonition-title> Evil JavaScript </strong><p>This post uses <a href=https://katex.org/>KaTeX</a> to render mathematical expressions.<p>To see the rendered mathematical expressions, you’ll need to enable JavaScript.</div></div></noscript><p><img alt="Just sprinkle a little bit of randomness, and voilà!" src=https://storopoli.com/blog/randomness/randomness-meme.jpg><p>Sometimes when you deal with complicated computations, either because of the input size or the complexity of the computation, you cannot get an answer in any feasible amount of time, no matter how much computational power you have.<p>When the limits of tractability are reached, we can give up deterministic computation and embrace <strong>randomness</strong> to get an answer in a much more reasonable time.<p>This is the case of <a href=https://en.wikipedia.org/wiki/Monte_Carlo_method>Monte Carlo methods</a>, which are a class of algorithms that use <strong>random sampling</strong> to solve mathematical problems. And, of course, like everything nice in math and computer science, it has the <strong>Von Neumann’s fingerprints</strong> all over it. Alas, that is a story for another post, that I already covered in <a href=https://storopoli.com/blog/von-neumann/>“Von Neumann: the Sharpest Mind of the 20th Century”</a>.<p>I was recently skimming over a textbook that I used to use in my undergraduate course on probability theory (Mitzenmacher and Upfal’s “Probability and Computing”<sup class=footnote-reference id=fr-pdf-1><a href=#fn-pdf>1</a></sup>, see references below), and I stumbled upon a very interesting algorithm for calculating the <strong>median</strong> of a list.<p>By the way, this textbook has one of the <strong>best covers</strong> in math textbooks. It is Alice in Wonderland dealing with a combinatorial explosion, see it below:</p><img alt="Probability and Computing: Randomization and Probabilistic Techniques in Algorithms and Data Analysis 2nd Edition" src=https://storopoli.com/processed_images/probability-and-computing.c46dbbb24f491e7b.jpg><p>The algorithm uses sampling to probabilistically find the <strong>median</strong>, and uses <a href="https://en.wikipedia.org/wiki/Chebyshev's_inequality">Chebyshev’s inequality</a>, an upper bound on the probability of deviation of a random variable from its mean. Since it is a probabilistic algorithm, it finds the median in $O(n)$ (linear time) with probability $1 - n^{-\frac{1}{4}}$ (close to $1$ for large $n$). Note that for any deterministic algorithm to find the median, it needs to sort the list, which takes $O(n \log n)$ (linearithmic time) on average or $O(n^2)$ (quadratic time) in the worst case<sup class=footnote-reference id=fr-quicksort-1><a href=#fn-quicksort>2</a></sup>. You can always iterate and run the algorithm until you get a result, but now the runtime is <strong>non-deterministic</strong>.<p>The nice thing about the algorithm is that Chebyshev’s inequality does not makes assumptions about the distribution of the variable, just that it has a <strong>finite variance</strong>. This is excellent since we can move away from the <strong>lala-land</strong> of normal distributions assumptions that everything is a Gaussian bell curve<sup class=footnote-reference id=fr-bayesian-1><a href=#fn-bayesian>3</a></sup>.<h2 id=chebyshev-s-inequality>Chebyshev’s Inequality</h2><p>Chebyshev’s inequality provides an upper bound on the probability of deviation of a random variable (with finite variance) from its mean.<p>The inequality is given by:<p>$$ P(|X - \mu| \geq k \sigma) \leq \frac{1}{k^2} $$<p>where $X$ is a random variable, $\mu$ is the mean, $\sigma$ is the standard deviation, and $k$ is a positive real number.<p>This is a consequence of the <a href="https://en.wikipedia.org/wiki/Markov's_inequality">Markov’s inequality</a>, and can be derived using simple algebra. The reader that is interested in the proof or more details, see the Wikipedia pages linked above.<p>Because Chebyshev’s inequality can be applied to any distribution with finite mean and variance, it generally gives <strong>looser bounds</strong> compared to what we might get if we knew more about the specific distribution. Here’s a table showing how much of the distribution’s values must lie within $k$ standard deviations of the mean:<table><thead><tr><th>$k$<th>Min. % within $k$ standard deviations<th>Max. % beyond $k$ standard deviations<tbody><tr><td>1<td>0%<td>100%<tr><td>$\sqrt{2}$<td>50%<td>50%<tr><td>2<td>75%<td>25%<tr><td>3<td>88.8889%<td>11.1111%<tr><td>4<td>93.75%<td>6.25%<tr><td>5<td>96%<td>4%<tr><td>10<td>99%<td>1%</table><p>For example, while we know that for a normal distribution about 68% of values lie within one standard deviation, Chebyshev only tells us that <strong>at least</strong> 0% must lie within one standard deviation! This is the price we pay for having a bound that works on any distribution. Yet, it is still a <strong>very useful bound</strong>.<h2 id=randomized-median>Randomized Median</h2><p>Alright, now let’s see in practice how this works. Below is the algorithm for finding the median of a list, as described in algorithm 3.1 in the “Probability and Computing” textbook:<p><strong>Input:</strong> A set $S$ of $n$ elements over a totally ordered universe.<p><strong>Output:</strong> The median element of $S$, denoted by $m$.<ol><li>Pick a (multi-)set $R$ of $\lceil n^{\frac{3}{4}} \rceil$ elements in $S$, chosen independently and uniformly at random with replacement.<li>Sort the set $R$.<li>Let $d$ be the $\bigg(\left\lfloor \frac{1}{2}n^{\frac{3}{4}} - \sqrt{n} \right\rfloor\bigg)$th smallest element in the sorted set $R$.<li>Let $u$ be the $\bigg(\left\lceil \frac{1}{2}n^{\frac{3}{4}} + \sqrt{n} \right\rceil\bigg)$th smallest element in the sorted set $R$.<li>By comparing every element in $S$ to $d$ and $u$, compute the set $C = \big\{x \in S : d \leq x \leq u \big\}$ and the numbers $\ell_d = \bigg| \big\{x \in S : x < d \big\}\bigg|$ and $\ell_u = \bigg| \big\{x \in S : x > u \big\}\bigg|$.<li>If $\ell_d > n/2$ or $\ell_u > n/2$ then FAIL.<li>If $\big|C\big| \leq 4n^{\frac{3}{4}}$ then sort the set $C$, otherwise FAIL.<li>Output the $\big(\lfloor \frac{n}{2} \rfloor - \ell_d + 1\big)$th element in the sorted order of $C$.</ol><p>As you can see, the algorithm starts by sampling a set of elements from the list, sorting them, and then using the sorted elements to find the median. How it finds the median is by using the set $C$, which is the set of elements in $S$ that are between $d$ and $u$, where $d$ is the lower bound and $u$ is the upper bound of the sampled set $R$.<p>The algorithm’s brilliance lies in its <strong>probabilistic guarantees</strong>. It can fail in three ways:<ol><li>Too few sampled elements are less than the true median<li>Too few sampled elements are greater than the true median<li>The set $C$ becomes too large to sort efficiently</ol><p>However, the probability of any of these failures occurring is <strong>remarkably small</strong>: less than $n^{-\frac{1}{4}}$. This means that as the input size grows, the chance of failure becomes increasingly negligible:<ul><li>For n = 10,000: failure probability ≤ 0.1<li>For n = 1,000,000: failure probability ≤ 0.032<li>For n = 100,000,000: failure probability ≤ 0.01</ul><p>When the algorithm doesn’t fail (which is the vast majority of the time), it is guaranteed to find the <strong>exact median</strong> in linear time. This is achieved by carefully choosing the sample size, $n^{\frac{3}{4}}$, and the buffer zone around the median, $\sqrt{n}$, to balance between:<ol><li>Having enough samples to make failure unlikely<li>Keeping the set $C$ small enough to sort quickly</ol><p>The algorithm provides two important guarantees:<ol><li><p><strong>Correctness</strong>: The algorithm is guaranteed to either FAIL or return the true median. This is proven using Chebyshev’s inequality in two steps. First, we show that the true median $m$ will be in set $C$ with high probability:</p> <ul><li>Let $Y_1$ be the count of sampled elements ≤ $m$ in $R$ <ul><li>When $Y_1 < \frac{1}{2}n^{\frac{3}{4}} - \sqrt{n}$, we call this event $\mathcal{E}_1$</ul><li>Let $Y_2$ be the count of sampled elements ≥ $m$ in $R$ <ul><li>When $Y_2 < \frac{1}{2}n^{\frac{3}{4}} - \sqrt{n}$, we call this event $\mathcal{E}_2$</ul><li>When $|C| > 4n^{\frac{3}{4}}$, we call this event $\mathcal{E}_3$<li>By Chebyshev’s inequality, each event has probability at most $\frac{1}{4}n^{-\frac{1}{4}}$</ul> <p>Second, we show that when $m$ is in $C$, we find it:</p> <ul><li>$\ell_d$ counts elements < $d$, so there are exactly $\big\lfloor \frac{n}{2} \big\rfloor - \ell_d$ elements between $d$ and $m$<li>Therefore, $m$ must be the $\bigg(\big\lfloor \frac{n}{2} \big\rfloor - \ell_d + 1\bigg)$th element in the sorted $C$</ul><li><p><strong>Linear Time</strong>: The algorithm runs in $O(n)$ time when it succeeds because:</p> <ul><li>Sampling and sorting $R$ takes $O\left(n^\frac{3}{4} \log n\right)$ time<li>Comparing all elements to $d$ and $u$ takes $O(n)$ time<li>Sorting $C$ takes $O\left(n^\frac{3}{4} \log n\right)$ time since $|C| \leq 4n^\frac{3}{4}$<li>All other operations are constant time</ul></ol><h3 id=why-these-guarantees-work>Why These Guarantees Work</h3><p>The key to understanding why this algorithm works lies in analyzing the <strong>probability of failure</strong>. Let’s look at how we bound the probability of having too few samples below the median (event $\mathcal{E}_1$):<ol><li><p>For each sampled element $i$, define an indicator variable $X_i$ where: $$ X_i = 1 \text{ if the $i$th sample is } \leq \text{ median} $$ $$ X_i = 0 \text{ otherwise} $$</p><li><p>Since we sample with replacement, the $X_i$ are independent. And since there are $\frac{n-1}{2} + 1$ elements ≤ median in $S$, we have: $$ P(X_i = 1) = \frac{\frac{n-1}{2} + 1}{n} = \frac{1}{2} + \frac{1}{2n} $$</p><li><p>Let $Y_1 = \sum_{i=1}^{n^{3/4}} X_i$ count samples ≤ median. This is a binomial random variable with:</p> <ul><li>Expected value: $E[Y_1] = n^{\frac{3}{4}}\left(\frac{1}{2} + \frac{1}{2n}\right)$<li>Variance: $Var[Y_1] < \frac{1}{4}n^{\frac{3}{4}}$</ul><li><p>Using Chebyshev’s inequality: $$ P \left(Y_1 < \frac{1}{2}n^{\frac{3}{4}} - \sqrt{n} \right) \leq \frac{Var[Y_1]}{n} < \frac{1}{4}n^{-\frac{1}{4}} $$</p></ol><p>This shows that both events $\mathcal{E}_1$ and $\mathcal{E}_2$ have probability at most $\frac{1}{4}n^{-\frac{1}{4}}$, and also that $\mathcal{E}_3$ has probability at most $\frac{1}{4}n^{-\frac{1}{4}}$:<p>$$ P(\mathcal{E}_1) \leq P(\mathcal{E}_2 + \mathcal{E}_3) \leq \frac{1}{2}n^{-\frac{1}{4}} $$<p>All these events combined demonstrate that the algorithm rarely fails: the probability of having too few samples on either side of the median decreases as $n^{-\frac{1}{4}}$, becoming negligible for large $n$. If higher reliability is needed, you can simply run the algorithm multiple times, as each run is independent.<h2 id=haskell-implementation>Haskell Implementation</h2><p>I implemented the algorithm in <strong>Haskell</strong>, because I stare at <strong>Rust</strong> code 8+ hours a day, and I want programming in a language that “if it compiles, it is guaranteed to run”. The only other language apart from Rust that has this property, and some might say that it is the only language that has this property, is Haskell.<p>The code can be found on GitHub at <a href=https://github.com/storopoli/randomized-median><code>storopoli/randomized-median</code></a>.<p>So let’s first go over the vanilla, classical, deterministic median algorithm:<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-meta z-function z-type-declaration z-haskell"><span class="z-entity z-name z-function z-haskell">median</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> (<span class="z-storage z-type z-haskell">Ord</span> <span class="z-variable z-other z-generic-type z-haskell">a</span>, <span class="z-storage z-type z-haskell">Fractional</span> <span class="z-variable z-other z-generic-type z-haskell">a</span>) <span class="z-keyword z-other z-big-arrow z-haskell">=></span> [<span class="z-variable z-other z-generic-type z-haskell">a</span>] <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-storage z-type z-haskell">Maybe</span> <span class="z-variable z-other z-generic-type z-haskell">a</span>
</span></span><span class="z-source z-haskell"><span class="z-meta z-function z-type-declaration z-haskell"></span>median <span class="z-constant z-language z-empty-list z-haskell">[]</span> <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">Nothing</span>
</span><span class="z-source z-haskell">median xs <span class="z-keyword z-operator z-haskell">=</span>
</span><span class="z-source z-haskell">  <span class="z-comment z-line z-double-dash z-haskell"><span class="z-punctuation z-definition z-comment z-haskell">--</span> First convert list to array for O(1) random access
</span></span><span class="z-source z-haskell">  <span class="z-keyword z-other z-haskell">let</span> n <span class="z-keyword z-operator z-haskell">=</span> length xs
</span><span class="z-source z-haskell">      arr <span class="z-keyword z-operator z-haskell">=</span> listArray (<span class="z-constant z-numeric z-integer z-decimal z-haskell">0</span><span class="z-punctuation z-separator z-comma z-haskell">,</span> n <span class="z-keyword z-operator z-haskell">-</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">1</span>) xs
</span><span class="z-source z-haskell">      <span class="z-comment z-line z-double-dash z-haskell"><span class="z-punctuation z-definition z-comment z-haskell">--</span> Sort the array elements
</span></span><span class="z-source z-haskell">      sorted <span class="z-keyword z-operator z-haskell">=</span> sort (elems arr)
</span><span class="z-source z-haskell">      sortedArr <span class="z-keyword z-operator z-haskell">=</span> listArray (<span class="z-constant z-numeric z-integer z-decimal z-haskell">0</span><span class="z-punctuation z-separator z-comma z-haskell">,</span> n <span class="z-keyword z-operator z-haskell">-</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">1</span>) sorted
</span><span class="z-source z-haskell">      mid <span class="z-keyword z-operator z-haskell">=</span> n <span class="z-keyword z-operator z-function z-infix z-haskell"><span class="z-punctuation z-definition z-entity z-haskell">`</span>div<span class="z-punctuation z-definition z-entity z-haskell">`</span></span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">2</span>
</span><span class="z-source z-haskell">   <span class="z-keyword z-other z-haskell">in</span> <span class="z-keyword z-control z-haskell">if</span> odd n
</span><span class="z-source z-haskell">        <span class="z-keyword z-control z-haskell">then</span> <span class="z-constant z-other z-haskell">Just</span> (sortedArr <span class="z-keyword z-operator z-haskell">!</span> mid)
</span><span class="z-source z-haskell">        <span class="z-keyword z-control z-haskell">else</span> <span class="z-constant z-other z-haskell">Just</span> ((sortedArr <span class="z-keyword z-operator z-haskell">!</span> (mid <span class="z-keyword z-operator z-haskell">-</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">1</span>) <span class="z-keyword z-operator z-haskell">+</span> sortedArr <span class="z-keyword z-operator z-haskell">!</span> mid) <span class="z-keyword z-operator z-haskell">/</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">2</span>)
</span></code></pre><p>First we define a function signature for the median function: it takes a list or elements of some type that is an instance of both the <code>Ord</code> type class, and the <code>Fractional</code> type class. This is because we must assure the Haskell compiler that the elements of the list can be ordered and that we can perform fractional arithmetic on them. It returns a <code>Maybe a</code> because the median is not defined for empty lists. The <code>Maybe</code> type is an instance of the <code>Monad</code><sup class=footnote-reference id=fr-monad-1><a href=#fn-monad>4</a></sup> type class, which allows us to use the <code>>>=</code> operator to chain computations that may fail. It can take two values <code>Nothing</code> or <code>Just a</code>, where <code>a</code> is the type of the elements of the list.<p>For the case of an empty list, we return <code>Nothing</code>. For the case of a non-empty list, we convert the list to an array, sort the array, and then find the median, returning the median as a <code>Just</code> value.<p>Now, let’s implement the randomized median algorithm:<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-meta z-function z-type-declaration z-haskell"><span class="z-entity z-name z-function z-haskell">randomizedMedian</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> (<span class="z-storage z-type z-haskell">Ord</span> <span class="z-variable z-other z-generic-type z-haskell">a</span>) <span class="z-keyword z-other z-big-arrow z-haskell">=></span> [<span class="z-variable z-other z-generic-type z-haskell">a</span>] <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-storage z-type z-haskell">Int</span> <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-storage z-type z-haskell">Maybe</span> <span class="z-variable z-other z-generic-type z-haskell">a</span>
</span></span><span class="z-source z-haskell"><span class="z-meta z-function z-type-declaration z-haskell"></span>randomizedMedian <span class="z-constant z-language z-empty-list z-haskell">[]</span> _ <span class="z-keyword z-operator z-haskell">=</span> <span class="z-constant z-other z-haskell">Nothing</span>
</span><span class="z-source z-haskell">randomizedMedian xs seed <span class="z-keyword z-operator z-haskell">=</span>
</span><span class="z-source z-haskell">  <span class="z-keyword z-other z-haskell">let</span> n <span class="z-keyword z-operator z-haskell">=</span> length xs
</span><span class="z-source z-haskell">      arr <span class="z-keyword z-operator z-haskell">=</span> listArray (<span class="z-constant z-numeric z-integer z-decimal z-haskell">0</span><span class="z-punctuation z-separator z-comma z-haskell">,</span> n <span class="z-keyword z-operator z-haskell">-</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">1</span>) xs
</span><span class="z-source z-haskell">
</span><span class="z-source z-haskell">      <span class="z-comment z-line z-double-dash z-haskell"><span class="z-punctuation z-definition z-comment z-haskell">--</span> Step 1: Sample n^(3/4) elements with replacement
</span></span><span class="z-source z-haskell">      sampleSize <span class="z-keyword z-operator z-haskell">=</span> ceiling (fromIntegral n ** (<span class="z-constant z-numeric z-integer z-decimal z-haskell">3</span> <span class="z-keyword z-operator z-haskell">/</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">4</span>))
</span><span class="z-source z-haskell">      gen <span class="z-keyword z-operator z-haskell">=</span> mkStdGen seed
</span><span class="z-source z-haskell">      indices <span class="z-keyword z-operator z-haskell">=</span> take sampleSize <span class="z-keyword z-operator z-haskell">$</span> randomRs (<span class="z-constant z-numeric z-integer z-decimal z-haskell">0</span><span class="z-punctuation z-separator z-comma z-haskell">,</span> n <span class="z-keyword z-operator z-haskell">-</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">1</span>) gen
</span><span class="z-source z-haskell">
</span><span class="z-source z-haskell">      <span class="z-comment z-line z-double-dash z-haskell"><span class="z-punctuation z-definition z-comment z-haskell">--</span> Step 2: Sort the sample
</span></span><span class="z-source z-haskell">      sample <span class="z-keyword z-operator z-haskell">=</span> sort [arr <span class="z-keyword z-operator z-haskell">!</span> i <span class="z-keyword z-operator z-haskell">|</span> i <span class="z-keyword z-operator z-haskell">&LT-</span> indices]
</span><span class="z-source z-haskell">      sampleArr <span class="z-keyword z-operator z-haskell">=</span> listArray (<span class="z-constant z-numeric z-integer z-decimal z-haskell">0</span><span class="z-punctuation z-separator z-comma z-haskell">,</span> length sample <span class="z-keyword z-operator z-haskell">-</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">1</span>) sample
</span><span class="z-source z-haskell">
</span><span class="z-source z-haskell">      <span class="z-comment z-line z-double-dash z-haskell"><span class="z-punctuation z-definition z-comment z-haskell">--</span> Step 3: Find d (the lower bound element)
</span></span><span class="z-source z-haskell">      dIndex <span class="z-keyword z-operator z-haskell">=</span> floor (fromIntegral n ** (<span class="z-constant z-numeric z-integer z-decimal z-haskell">3</span> <span class="z-keyword z-operator z-haskell">/</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">4</span>) <span class="z-keyword z-operator z-haskell">/</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">2</span> <span class="z-keyword z-operator z-haskell">-</span> sqrt (fromIntegral n))
</span><span class="z-source z-haskell">      d <span class="z-keyword z-operator z-haskell">=</span>
</span><span class="z-source z-haskell">        <span class="z-keyword z-control z-haskell">if</span> dIndex <span class="z-keyword z-operator z-haskell">>=</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">0</span> && dIndex <span class="z-keyword z-operator z-haskell"><</span> length sample
</span><span class="z-source z-haskell">          <span class="z-keyword z-control z-haskell">then</span> sampleArr <span class="z-keyword z-operator z-haskell">!</span> dIndex
</span><span class="z-source z-haskell">          <span class="z-keyword z-control z-haskell">else</span> error <span class="z-string z-quoted z-double z-haskell"><span class="z-punctuation z-definition z-string z-begin z-haskell">"</span>Invalid d index<span class="z-punctuation z-definition z-string z-end z-haskell">"</span></span>
</span><span class="z-source z-haskell">
</span><span class="z-source z-haskell">      <span class="z-comment z-line z-double-dash z-haskell"><span class="z-punctuation z-definition z-comment z-haskell">--</span> Step 4: Find u (the upper bound element)
</span></span><span class="z-source z-haskell">      uIndex <span class="z-keyword z-operator z-haskell">=</span> floor (fromIntegral n ** (<span class="z-constant z-numeric z-integer z-decimal z-haskell">3</span> <span class="z-keyword z-operator z-haskell">/</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">4</span>) <span class="z-keyword z-operator z-haskell">/</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">2</span> <span class="z-keyword z-operator z-haskell">+</span> sqrt (fromIntegral n))
</span><span class="z-source z-haskell">      u <span class="z-keyword z-operator z-haskell">=</span>
</span><span class="z-source z-haskell">        <span class="z-keyword z-control z-haskell">if</span> uIndex <span class="z-keyword z-operator z-haskell">>=</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">0</span> && uIndex <span class="z-keyword z-operator z-haskell"><</span> length sample
</span><span class="z-source z-haskell">          <span class="z-keyword z-control z-haskell">then</span> sampleArr <span class="z-keyword z-operator z-haskell">!</span> uIndex
</span><span class="z-source z-haskell">          <span class="z-keyword z-control z-haskell">else</span> error <span class="z-string z-quoted z-double z-haskell"><span class="z-punctuation z-definition z-string z-begin z-haskell">"</span>Invalid u index<span class="z-punctuation z-definition z-string z-end z-haskell">"</span></span>
</span><span class="z-source z-haskell">
</span><span class="z-source z-haskell">      <span class="z-comment z-line z-double-dash z-haskell"><span class="z-punctuation z-definition z-comment z-haskell">--</span> Step 5: Compute set C and counts
</span></span><span class="z-source z-haskell">      ld <span class="z-keyword z-operator z-haskell">=</span> length <span class="z-keyword z-operator z-haskell">$</span> filter (<span class="z-keyword z-operator z-haskell"><</span> d) xs
</span><span class="z-source z-haskell">      lu <span class="z-keyword z-operator z-haskell">=</span> length <span class="z-keyword z-operator z-haskell">$</span> filter (<span class="z-keyword z-operator z-haskell">></span> u) xs
</span><span class="z-source z-haskell">      c <span class="z-keyword z-operator z-haskell">=</span> sort <span class="z-keyword z-operator z-haskell">$</span> filter (<span class="z-keyword z-operator z-haskell">\</span>x <span class="z-keyword z-operator z-haskell">-></span> d <span class="z-keyword z-operator z-haskell"><=</span> x && x <span class="z-keyword z-operator z-haskell"><=</span> u) xs
</span><span class="z-source z-haskell">
</span><span class="z-source z-haskell">      <span class="z-comment z-line z-double-dash z-haskell"><span class="z-punctuation z-definition z-comment z-haskell">--</span> Step 6 & 7: Check failure conditions
</span></span><span class="z-source z-haskell">      halfN <span class="z-keyword z-operator z-haskell">=</span> n <span class="z-keyword z-operator z-function z-infix z-haskell"><span class="z-punctuation z-definition z-entity z-haskell">`</span>div<span class="z-punctuation z-definition z-entity z-haskell">`</span></span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">2</span>
</span><span class="z-source z-haskell">   <span class="z-keyword z-other z-haskell">in</span> ( <span class="z-keyword z-control z-haskell">if</span> ((ld <span class="z-keyword z-operator z-haskell">></span> halfN <span class="z-keyword z-operator z-haskell">||</span> lu <span class="z-keyword z-operator z-haskell">></span> halfN) <span class="z-keyword z-operator z-haskell">||</span> (length c <span class="z-keyword z-operator z-haskell">></span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">4</span> * sampleSize)) <span class="z-keyword z-operator z-haskell">||</span> null c
</span><span class="z-source z-haskell">          <span class="z-keyword z-control z-haskell">then</span> <span class="z-constant z-other z-haskell">Nothing</span>
</span><span class="z-source z-haskell">          <span class="z-keyword z-control z-haskell">else</span>
</span><span class="z-source z-haskell">            ( <span class="z-keyword z-other z-haskell">let</span> targetIndex <span class="z-keyword z-operator z-haskell">=</span> halfN <span class="z-keyword z-operator z-haskell">-</span> ld
</span><span class="z-source z-haskell">               <span class="z-keyword z-other z-haskell">in</span> <span class="z-keyword z-control z-haskell">if</span> targetIndex <span class="z-keyword z-operator z-haskell">>=</span> <span class="z-constant z-numeric z-integer z-decimal z-haskell">0</span> && targetIndex <span class="z-keyword z-operator z-haskell"><</span> length c
</span><span class="z-source z-haskell">                    <span class="z-keyword z-control z-haskell">then</span>
</span><span class="z-source z-haskell">                      <span class="z-comment z-line z-double-dash z-haskell"><span class="z-punctuation z-definition z-comment z-haskell">--</span> Step 8: Output the median
</span></span><span class="z-source z-haskell">                      <span class="z-constant z-other z-haskell">Just</span> (c <span class="z-keyword z-operator z-haskell">!!</span> targetIndex)
</span><span class="z-source z-haskell">                    <span class="z-keyword z-control z-haskell">else</span>
</span><span class="z-source z-haskell">                      <span class="z-constant z-other z-haskell">Nothing</span>
</span><span class="z-source z-haskell">            )
</span><span class="z-source z-haskell">      )
</span></code></pre><p>I’ve added comments to the code with respect to the algorithm steps. First, the function signature is almost the same as the deterministic median function. There are two differences:<ol><li>The elements of the list does not need to be a <code>Fractional</code> type.<li>We now take an additional parameter, <code>seed</code>, which is the seed for the random number generator. This is needed since we are using a random number generator to sample the elements from the list.</ol><p>As before, for the case of an empty list, we return <code>Nothing</code>.<p>For the case of a non-empty list, we first convert the list to an array, and then sample <code>n^(3/4)</code> elements from the list with replacement. We use the <a href=https://hackage.haskell.org/package/random-1.1/docs/System-Random.html#v:randomR><code>randomRs</code></a> function to generate a list of random indices, it generates an infinite list of random values within the specified range (in this case, from <code>0 to n-1</code>), hence sampling with replacement. Then, we take the first <code>n^(3/4)</code> elements from the list. Next, we sort the sample and convert it to an array.<p>Next, we find the lower and upper bounds of the sample. We do this by finding the index of the element at position <code>n^(3/4)/2 - sqrt(n)</code> and <code>n^(3/4)/2 + sqrt(n)</code> in the sorted sample. We then take the element at these indices as the lower and upper bounds.<p>Then, we compute the set $C$ and the counts $\ell_d$ and $\ell_u$. We do this by filtering the list with the lower and upper bounds.<p>Next, we check if the set $C$ is too large to sort efficiently. If it is, we return <code>Nothing</code>. Otherwise, we sort the set $C$ and find the median.<h2 id=results>Results</h2><p>Here’s the result by running the algorithm against a randomly shuffled list of contiguous integers from 1 to 10,000,001 using the <strong>magical number 42</strong> as the seed of our random number generator. As you can see both the exact and randomized median algorithms find the right median value:<p>$$ \frac{10,000,001}{2} = 5,000,001 $$<p>since $10,000,001$ is odd, the median is the element at position $\frac{10,000,001}{2} = 5,000,001$.<pre class="language-bash z-code" data-lang=bash><code class=language-bash data-lang=bash><span class="z-source z-shell z-bash"><span class="z-keyword z-operator z-assignment z-shell">=</span><span class="z-string z-unquoted z-shell">===========================</span>
</span><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Testing</span></span><span class="z-meta z-function-call z-arguments z-shell"> with 10_000_001 shuffled elements</span>
</span><span class="z-source z-shell z-bash">
</span><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Exact</span></span><span class="z-meta z-function-call z-arguments z-shell"> median calculation:</span>
</span><span class="z-source z-shell z-bash">  <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Result:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 5000001.0</span>
</span><span class="z-source z-shell z-bash">  <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Time:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 18.906611 seconds</span>
</span><span class="z-source z-shell z-bash">
</span><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Randomized</span></span><span class="z-meta z-function-call z-arguments z-shell"> approximate median calculation:</span>
</span><span class="z-source z-shell z-bash">  <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Result:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 5000001.0</span>
</span><span class="z-source z-shell z-bash">  <span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Time:</span></span><span class="z-meta z-function-call z-arguments z-shell"> 1.095511 seconds</span>
</span><span class="z-source z-shell z-bash">
</span><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Error</span></span><span class="z-meta z-function-call z-arguments z-shell"> percentage: 0.0000<span class="z-meta z-group z-expansion z-job z-shell"><span class="z-punctuation z-definition z-variable z-job z-shell">%</span></span></span>
</span><span class="z-source z-shell z-bash"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">Speedup</span></span><span class="z-meta z-function-call z-arguments z-shell"> factor: 17.26x</span>
</span></code></pre><p>The randomized median algorithm for the case of $n = 10,000,001$ is at least <strong>17x faster</strong> than the exact median calculation. That is an <strong>order of magnitude improvement</strong> over the deterministic median algorithm.<h2 id=conclusion>Conclusion</h2><p>I love the inequalities of the <strong>Russian school of probability</strong>, Markov, Chebyshev, etc., since it does not depend on any underlying distributional assumptions. Chebyshev’s inequality depends on the random variable having a finite mean and variance, and Markov’s inequality depends on the random variable being non-negative but does not depend on finite variances.<p>Assuming that the underlying variable has finite variance is a reasonable assumption to make most of the time for your data. To be fair, there are some random variables that can have infinite variance, such as the <a href=https://en.wikipedia.org/wiki/Cauchy_distribution>Cauchy</a> or <a href=https://en.wikipedia.org/wiki/Pareto_distribution>Pareto</a> distributions, but these are <strong>extremely rare</strong> for you to cross paths with.<p>Another thing to note is that instead of the Chebyshev’s inequality, we could have used the <a href=https://en.wikipedia.org/wiki/Chernoff_bound>Chernoff bound</a> to get a <strong>tighter bound</strong> on the probability of failure. But that is “left as an exercise to the reader”.<p>Finally, if you are intrigued to see how powerful these inequalities can be in probability theory, I highly recommend Nassim’s Taleb technical book <a href=https://arxiv.org/abs/2001.10488>“Statistical Consequences of Fat Tails: Real World Preasymptotics, Epistemology, and Applications”</a> which is freely available on arXiv.<h2 id=references>References</h2><ul><li>Michael Mitzenmacher and Eli Upfal, “Probability and Computing: Randomization and Probabilistic Techniques in Algorithms and Data Analysis 2nd Edition”, ISBN: 978-1107154889</ul><footer class=footnotes><ol class=footnotes-list><li id=fn-pdf><p>The PDF is freely available <a href=http://lib.ysu.am/open_books/413311.pdf>here</a>. <a href=#fr-pdf-1>↩</a></p><li id=fn-quicksort><p>Note that I am comparing against quicksort since it uses $O(\log n)$ space, whereas merge sort would use $O(n)$ space with the worst case is $O(n)$. <a href=#fr-quicksort-1>↩</a></p><li id=fn-bayesian><p>For my Bayesian rant, see <a href=https://storopoli.com/blog/lindley-paradox/>“Lindley’s Paradox, or The consistency of Bayesian Thinking”</a>. <a href=#fr-bayesian-1>↩</a></p><li id=fn-monad><p>Yes M word mentioned. If you want a good introduction to Haskell functors, applicatives, and monads, see <a href=https://www.adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html>“Functors, Applicatives, And Monads In Pictures”</a> <a href=#fr-monad-1>↩</a></p></ol></footer></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=overlay for=toc-toggle></label><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://storopoli.com/blog/randomness/#chebyshev-s-inequality>Chebyshev’s Inequality</a><li><a href=https://storopoli.com/blog/randomness/#randomized-median>Randomized Median</a> <ul><li><a href=https://storopoli.com/blog/randomness/#why-these-guarantees-work>Why These Guarantees Work</a></ul><li><a href=https://storopoli.com/blog/randomness/#haskell-implementation>Haskell Implementation</a><li><a href=https://storopoli.com/blog/randomness/#results>Results</a><li><a href=https://storopoli.com/blog/randomness/#conclusion>Conclusion</a><li><a href=https://storopoli.com/blog/randomness/#references>References</a></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><link href=https://storopoli.com/katex.min.css rel=stylesheet><script defer src=https://storopoli.com/js/katex.min.js></script><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://storopoli.com/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://storopoli.com/atom.xml> <img alt=feed loading=lazy src=https://storopoli.com/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=mailto:jose@storopoli.com> <img alt=email loading=lazy src=https://storopoli.com/social_icons/email.svg title=email> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://storopoli.com/publickey.txt> <img alt=pgp loading=lazy src=https://storopoli.com/social_icons/key.svg title=pgp> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/storopoli/> <img alt=github loading=lazy src=https://storopoli.com/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://matrix.to/#/@jose:storopoli.com> <img alt=matrix loading=lazy src=https://storopoli.com/social_icons/matrix.svg title=matrix> </a><li><a class="nav-links no-hover-padding social" href="https://simplex.chat/contact#/?v=2-5&smp=smp%3A%2F%2FUkMFNAXLXeAAe0beCa4w6X_zp18PwxSaSjY17BKUGXQ%3D%40smp12.simplex.im%2FUXrwU_eqdgeHQ6HYehFs0s8VRHOr3k47%23%2F%3Fv%3D1-2%26dh%3DMCowBQYDK2VuAyEApVAYxmE0bpIIiPftNjehy4qOoa14ubyEGzbRX_BlO0w%253D%26srv%3Die42b5weq7zdkghocs3mgxdjeuycheeqqmksntj57rmejagmg4eor5yd.onion" rel=" me"> <img alt=simplex loading=lazy src=https://storopoli.com/social_icons/simplex.svg title=simplex> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://orcid.org/0000-0002-0559-5176> <img alt=orcid loading=lazy src=https://storopoli.com/social_icons/orcid.svg title=orcid> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> • <a href=https://github.com/storopoli/storopoli.com> Site source </a></small></div></section></footer>