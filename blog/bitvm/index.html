<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data: 'self';img-src 'self' https://* data:;media-src 'self';style-src 'self' 'unsafe-inline';frame-src player.vimeo.com https://www.youtube-nocookie.com https://www.youtube.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://storopoli.com name=base><title>
Jose Storopoli, PhD • BitVM: how to bridge using 1-of-N trust assumptions</title><link href=https://storopoli.com/favicon.svg rel=icon type=image/png><link title="Jose Storopoli, PhD - Atom Feed" href=https://storopoli.com/atom.xml rel=alternate type=application/atom+xml><link href="https://storopoli.com/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://storopoli.com/main.css?h=6b1dda977391dad0c76e" rel=stylesheet><link href="https://storopoli.com/extra.css?h=33c2dfb527f758787862" rel=stylesheet><link href="https://storopoli.com/skins/teal.css?h=bd19e558a52d678a50de" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Personal website of Jose Storopoli, PhD" name=description><meta content="Personal website of Jose Storopoli, PhD" property=og:description><meta content="BitVM: how to bridge using 1-of-N trust assumptions" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://storopoli.com/blog/bitvm/ property=og:url><meta content="Jose Storopoli, PhD" property=og:site_name><noscript><link href=https://storopoli.com/no_js.css rel=stylesheet></noscript><script src=https://storopoli.com/js/initializeTheme.min.js></script><script defer src=https://storopoli.com/js/themeSwitcher.min.js></script><body><header><nav class=navbar><div class=nav-title><a class=home-title href=https://storopoli.com>Jose Storopoli, PhD</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://storopoli.com/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://storopoli.com/tags/>tags </a><li class=menu-icons-container><ul class=menu-icons-group><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content><main><article><h1 class=article-title>BitVM: how to bridge using 1-of-N trust assumptions</h1><ul class=meta><span class="hidden p-author h-card"> <a title="Jose Storopoli, PhD" class=u-url href=https://storopoli.com rel=author>Jose Storopoli, PhD</a> </span><li>10th Feb 2025<li title="5431 words"><span aria-hidden=true class=separator>•</span>28 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a href=https://storopoli.com/tags/math/>math</a>, <li class=tag><a href=https://storopoli.com/tags/cryptography/>cryptography</a>, <li class=tag><a href=https://storopoli.com/tags/bitcoin/>bitcoin</a></ul><div class=toc-container><h3>Table of Contents</h3><ul><li><a href=https://storopoli.com/blog/bitvm/#big-idea-1-verified-computation>Big Idea 1: Verified Computation</a><li><a href=https://storopoli.com/blog/bitvm/#big-idea-2-groth16-bitcoin-script-compiler>Big Idea 2: Groth16 Bitcoin Script Compiler</a><li><a href=https://storopoli.com/blog/bitvm/#big-idea-3-emulating-covenants-with-connector-outputs>Big Idea 3: Emulating Covenants with Connector Outputs</a><li><a href=https://storopoli.com/blog/bitvm/#what-can-covenants-bring-to-bitvm>What can covenants bring to BitVM?</a><li><a href=https://storopoli.com/blog/bitvm/#conclusion>Conclusion</a></ul></div><section class=body><noscript><div class="admonition warning"><div class="admonition-icon admonition-icon-warning"></div><div class=admonition-content><strong class=admonition-title> Evil JavaScript </strong><p>This post uses <a href=https://katex.org/>KaTeX</a> to render mathematical expressions.<p>To see the rendered mathematical expressions, you’ll need to enable JavaScript.</div></div></noscript><noscript><div class="admonition warning"><div class="admonition-icon admonition-icon-warning"></div><div class=admonition-content><strong class=admonition-title> Evil JavaScript </strong><p>This post uses <a href=https://mermaid.js.org>Mermaid</a> to render flowcharts.<p>To see the rendered flowcharts, you’ll need to enable JavaScript.</div></div></noscript><div class="admonition info"><div class="admonition-icon admonition-icon-info"></div><div class=admonition-content><strong class=admonition-title>BTC++ Talk</strong><p>This post is the written version of my very condensed 45-minute talk at <a href=https://btcpp.dev/conf/floripa>BTC++ 2025 Floripa</a>. You can watch the talk <a href=https://youtu.be/gHoSpAgI7Xk>here</a>.</p><style>.embed-container{max-width:100%;height:0;padding-bottom:56.25%;position:relative;overflow:hidden}.embed-container iframe,.embed-container object,.embed-container embed{width:100%;height:100%;position:absolute;top:0;left:0}</style><div class=embed-container><iframe allowfullscreen frameborder=0 src=https://www.youtube.com/embed/gHoSpAgI7Xk></iframe></div></div></div><p><strong>BitVM is a bridge between Bitcoin and a sidesystem</strong>. Generally, these bridges are secured by a federated multisig, where to bridge-out you need to have a majority of the federation. Mathematically, this is a $(\frac{N}{2}+1)$-of-$N$ trust model. This is not ideal since it’s a “trust me bro” situation and the “bros” are the majority of the bridge. BitVM is different, since it can drastically reduce the trust assumptions. It is a <strong>$1$-of-$N$ trust model, in which as long as you have one live honest operator, you can withdraw on-chain</strong>.<p><img alt="BitVM Meme" src=https://storopoli.com/blog/bitvm/bitvm.jpg><p>I am part of the <strong><a href=https://alpenlabs.io>Alpen Labs</a> engineering team that is building <a href=https://stratabtc.org>Strata: a BitVM-based rollup on Bitcoin</a></strong>. Strata is also part of the <a href=https://bitvm.org/>BitVM Alliance</a>: a partnership to accelerate the development and implementation of BitVM project.<p>This post has a lot of overlaps with my previous post on <a href=https://storopoli.com/blog/zkp/>“Some Intuitions on Zero-Knowledge Proofs”</a>. If you want to know more about Zero-Knowledge Proofs (ZKPs), then I’d suggest you read that post first.<div class="admonition tip"><div class="admonition-icon admonition-icon-tip"></div><div class=admonition-content><strong class=admonition-title>Links and Footnotes</strong><p>This post is filled with external links and footnotes. If you want to dive deeper into any topic that has one of these, feel free to do so. The idea was to give a general overview the concepts, while also allowing you to tune your experience by giving you a bunch of tangents and rabbit holes to explore if wanted.</div></div><p>I’m going to present BitVM in it’s main three big ideas:<ol><li><strong>Verified Computation</strong><li><strong>Groth16 Bitcoin Script Compiler</strong><li><strong>Emulating Covenants with Connector Outputs</strong></ol><p><img alt="Three Big Ideas" src=https://storopoli.com/blog/bitvm/3_big_ideas.png><p>The only new idea that BitVM brings to the table is the Groth16 Bitcoin script compiler. Verified computation is the premise of ZK-SNARKs, and emulating covenants with connector outputs was already used by the <a href=https://ark-protocol.org/>Ark protocol</a>.<h2 id=big-idea-1-verified-computation>Big Idea 1: Verified Computation</h2><p>Suppose you have a function that does some complicated stuff and performs some computation. Then, this function can be represented as an <a href=https://en.wikipedia.org/wiki/Arithmetic_circuit><strong>arithmetic circuit</strong></a><sup class=footnote-reference id=fr-peano-1><a href=#fn-peano>1</a></sup>.<p>An arithmetic circuit is a directed acyclic graph (DAG) where:<ul><li>Every indegree-zero node is an input gate that represents a variable $x_i$<li>Every node with indegree $>1$ is either: <ul><li>an addition gate, $+$, that represents the sum of its children<li>a multiplication gate, $\times$, that represents the product of its children</ul></ul><p>Here’s an example of an arithmetic circuit that represents the function<p>$$f(x_1, x_2) = x_1 \cdot x_2 + x_1$$</p><noscript><strong>⚠️ JavaScript is required to render the diagram.</strong></noscript><pre class="mermaid invertible-image">
    flowchart TD
x1["x₁"]
x2["x₂"]
mul["×"]
add["\+"]

x1 --> mul
x2 --> mul
mul --> add
x1 --> add
</pre><p>In the circuit above, the input gates are $x_1$ and $x_{2}$, the product gate computes $x_1 \cdot x_2$, and the sum gate computes the result of the product gate added to $x_1$. All of this evaluates to $x_1 \cdot x_2 + x_1$.<p>This stems due to the fact that any <a href=https://en.wikipedia.org/wiki/NP_(complexity)>NP problem</a><sup class=footnote-reference id=fr-np-complete-1><a href=#fn-np-complete>2</a></sup> can be reduced in polynomial time by a deterministic Turing machine to the <a href=https://en.wikipedia.org/wiki/Boolean_satisfiability_problem>Boolean satisfiability problem</a><sup class=footnote-reference id=fr-boolean-funs-1><a href=#fn-boolean-funs>3</a></sup>. This is known as the <a href=https://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem>Cook-Levin theorem</a>, and it is a fundamental result in theoretical computer science.<p>In computer science, we have two main classes of problems:<ul><li>$\cal{P}$ problems, which are <strong>easy to solve and verify</strong>.<li>$\cal{NP}$ problems, which are <strong>hard to solve, but <em>easy</em> to verify</strong>.</ul><p>$\cal{P}$ stems from polynomial time, and contains all decision problems that can be solved by a deterministic Turing machine using a polynomial amount of computation time, or polynomial time. $\cal{NP}$ stems from non-deterministic polynomial time, and is the set of decision problems for which the problem instances, where the answer is “yes”, have proofs verifiable in polynomial time by a deterministic Turing machine.<p><img alt="P vs NP" src=https://storopoli.com/blog/bitvm/p_np.png><p>According to the Cook-Levin theorem, once you find an algorithm that solves one of the $\cal{NP}$ problems in polynomial time, you can use it to solve <strong><em>any</em> $\cal{NP}$ problem in polynomial time</strong>. But we haven’t yet found such algorithms for any $\cal{NP}$ problem. Heck, we don’t even know if $\cal{P} \ne \cal{NP}$. It is highly speculated, but yet still an open question<sup class=footnote-reference id=fr-millennium-problems-1><a href=#fn-millennium-problems>4</a></sup>.<p>Moving on, <strong>any (finite) arithmetic circuit can be transformed into a big (finite) polynomial</strong>, by using techniques such as <a href=https://alinush.github.io/qap-r1cs>Rank-1 Constraint System (R1CS), quadratic arithmetic program (QAP)</a>; and many others. This means that we can map any arithmetic circuit to a polynomial, and vice-versa; and one operation in each side of the map, can be mapped to a single operation in the other side.<p>Finally, we can <strong>cryptographically commit to a polynomial using <a href=https://en.wikipedia.org/wiki/Commitment_scheme#KZG_commitment>polynomial commitment schemes (PCS)</a></strong>. This means that we <strong>also commit to a certain arithmetic circuit, given that we know the unique polynomial that it represents</strong>. This commitment allow us to create <strong>very succinct zero-knowledge proofs that some computation was performed given certain inputs</strong>. We can represent this with proof as $\pi$ which takes as public-accessible inputs $x$, and private-accessible inputs $w$ (as in witness), and outputs $y$:<p>$$\pi(x; w) = y$$<p>Let’s define verifier $V$ that has access to the arithmetic circuit $C$, the inputs $x$, and the proof $\pi$. Note that $V$ does not have access to the witness $w$, which are private inputs. Additionally, $V$ may or may not have access to the output $y$ of the whole computation. Also, we’ll define a prover $P$ that has access to everything $V$ has, with the addition of the witness $w$.<p>This proof $\pi$ has three main properties:<ol><li><p><strong>Completeness</strong>: If the statement is true, the verifier will accept the proof.</p> <p>$$ \Pr\big[V(\pi, x) = \text{accept} \big] = 1. $$</p> <p>Here $\Pr\big[V(\pi(x)) = \text{accept} \big]$ denotes the probability that the verifier accepts the proof given a proof $\pi$, and inputs $x$.</p><li><p><strong>Soundness</strong>: If the statement is <em>false</em>, no cheating prover can convince an honest verifier that it is true, except with some negligible probability <sup class=footnote-reference id=fr-negligible-1><a href=#fn-negligible>5</a></sup>.</p> <p>$$ \forall A, \forall x, \forall \pi: \Pr\big[V(A, \pi, x) = \text{accept} \big] < \text{negligible}. $$</p> <p>Here $\Pr\big[V(A, \pi) = \text{accept} \big]$ denotes the probability that the verifier accepts the proof given an adversary $A$, a proof $\pi$, and <em>public</em> inputs $x$.</p><li><p><strong>Zero-Knowledge</strong>: If the statement is true, the verifier learns nothing about the secret $w$.</p></ol><p>There are many commitment schemes, even ones that don’t use polynomials. But a succinct zero knowledge system also needs an interactive oracle proof (IOP). One of such schemes is <a href=https://alinush.github.io/groth16>Groth16</a>, named after Jens Groth, who published the <a href=https://eprint.iacr.org/2016/260>paper describing it in 2016</a>.<p><strong>Groth16 uses a mathematical tool called <a href=https://en.wikipedia.org/wiki/Bilinear_map>bilinear maps</a> or <a href=https://alinush.github.io/pairings>pairing functions</a></strong>. This is generally applied to vector spaces, but they can work in elliptic curves (EC) as well. It allows us to have VERY succinct proofs. I’m not gonna cover the math behind EC pairings. Instead, suffices to know that an EC pairing, given three groups $G_1$, $G_2$, and $G_T$ (as in target group), is a function $e$:<p>$$e: G_1 \times G_2 \rightarrow G_T$$<p>In other words, it takes any two elements in $G_1$ and $G_2$; and outputs a group element in $G_T$.<p><strong>Groth16 proofs are very succinct</strong>. It consists of 3 group elements (2 from $G_1$ and 1 from $G_2$) which amounts <strong>from 128 to 192 bytes</strong>.<p>As an example suppose that I know how to calculate the 100th million digit of $\pi$. I publicly produce a VERY big arithmetic circuit, and cryptographically commit to it using a polynomial commitment scheme. I proceed by performing the HUGE computation, and sending to you, the prover, $x$ and $\pi$: the inputs to this circuit and the proof that I’ve performed the computation correctly. By verifying the proof, you can convince yourself that I know the 100th million digit of $\pi$ without gaining any knowledge of this digit at all.<p>In fact, to classify as <strong>succinct</strong>, this proving system must output proofs that are <strong>at most poly-logarithmic</strong> in the size of the circuit $C$, denoted as $|C|$, that it was committed and used to perform the computation that the prover wants to prove. Additionally, the verification time must also be poly-logarithmic in $C$. This means that <strong>both the proof size and verification time complexity must be at most</strong>:<p>$$O(\log^k |C|)$$<p>for some constant $k>1$.<p>Since Groth16, outputs proofs that are between 128 and 192 bytes, and also has a <strong>constant-time verification</strong>, due to the face that it is just checking 3 group elements, irrespectively of the size of the circuit $C$, then <strong>Groth16 is a succinct zero-knowledge proof system</strong>. In fact, it is currently the most succinct one that we know so far<sup class=footnote-reference id=fr-research-1><a href=#fn-research>6</a></sup>.<p>This is something quite marvelous. Imagine that you have ANY computation whatsoever, and I can prove to you that I’ve done it by sending only a very succinct ~200-byte proof and you are completely convinced that I did it. This is called <strong><a href=https://en.wikipedia.org/wiki/Verifiable_computing>verifiable computing</a></strong>, which crypto-bros call “zero-knowledge”. We already have zero-knowledge in classical cryptography: “Hey I know a secret key and here’s a signature to prove to you”. But the real novelty here is that <strong>we can prove that I did a computation without revealing the computation itself</strong>.<p>To finalize, there are some caveats in using Groth16. Yes, we have the <strong>best ZK-SNARK in terms of proof size and verification time</strong>. However, the setup is what we call a <strong>“trusted setup” that is also non-universal</strong>. This means that we need some sort of ceremony to setup the protocol, which includes the prover and verifier keys. This can be done in a Multi-Party Computation (MPC) style, with several parties joining the ceremony. Each one of these parties will contribute with some random secret data towards the setup of the protocol. <strong>As long as one of them throw away their secret data, the protocol is secure</strong><sup class=footnote-reference id=fr-ceremony-1><a href=#fn-ceremony>7</a></sup>. This means that no one can prove false statements or make a proof for a computation that was not performed. Additionally, the setup is done for a single circuit. Hence, you can only prove stuff that was done in a simple computation context. You can vary the inputs as much as you like, but the circuit will always be the same. To get a different circuit using Groth16, you need to perform a new setup.<h2 id=big-idea-2-groth16-bitcoin-script-compiler>Big Idea 2: Groth16 Bitcoin Script Compiler</h2><p>The second big idea is to <strong>overcome Bitcoin’s Script limitations by creating a Groth16 verifier using Bitcoin Script</strong>.<p><strong>Bitcoin Script</strong> is VERY limited. It is a <strong>stack-based language, and it has a very limited number of opcodes that pops and pushes values into the stack; or manipulates the stack</strong>.<p>Most opcodes deal with verifying signatures since that is the most common usecase for Bitcoin Script. However, Bitcoin Script can also do some things such as: <strong>hashing values and checking equality</strong>. Additionally, we also have an <strong>alternate stack, called “alt stack”, which is kinda a buffer for storing values</strong>.<p>With respect to math operations we have, hold your breath, <strong><em>only</em> 32-bit addition and subtraction</strong>. We don’t have multiplication and division, modular division, or bit-rotations. Heck, we cannot even <em>concatenate</em> two values into a single one. This has some historical reasons, and the short story is that Satoshi was scared of people torpedoing the network by exploding the stack, and eventually crashing nodes by using these “dark arts” arithmetic operations. The network was in its early days, and very fragile. Instead of carefully setting guard-rails so that people don’t do stupid dangerous things, he pretty much <strong>disabled<sup class=footnote-reference id=fr-satoshi-commit-1><a href=#fn-satoshi-commit>8</a></sup> all the “dark arts” arithmetic operations</strong>.<p>Bitcoin Script is different than Ethereum’s EVM. In the EVM, you can do whatever you want. It is (bounded) Turing-complete. You just need to make sure that you have enough gas to pay for the computation. However in Bitcoin, the fees are calculated from the transaction size. This is possible because of the very limited expressiveness that Bitcoin Script has. All nodes will run your transaction’s Script and verify it irrespectively of the size of the Script, within the relevant size limits, of course.<p>Bitcoin, prior to the Taproot upgrade, had limitations to a maximum of 1,000 stack elements, and 201 opcodes per program. With Taproot, we don’t have more opcodes limitations, but the 1,000 stack elements limitation is still there.<p>Remember that to <strong>verify a Groth16 proof we need to do some elliptic curve pairings and check 3 group elements</strong>? This means that, technically, we can have a Groth16 verifier in Bitcoin Script. Just like the golden rule of JavaScript: “if something can be built using JavaScript, it WILL be built using JavaScript”; we can tweak it to be the <strong>golden rule of Bitcoin Script: “if something can be built using Bitcoin Script, it WILL be built using Bitcoin Script”</strong>. To achieve a Groth16 verifier in Bitcoin Script, we just need to be <strong>able to do 256-bit multiplication using only 32-bit addition operations</strong>. And without the 201-opcodes limitation, that Taproot upgrade, <strong>we can have a Groth16 verifier in Bitcoin Script</strong>.<p>It turns out that this Script is kinda big. <strong>If you put it in a single transaction, it will be around 1GB</strong>. Not cool! Even if we are BFF with some miners, to not be limited by the transaction standardness requirements<sup class=footnote-reference id=fr-transaction-standardness-1><a href=#fn-transaction-standardness>9</a></sup>, we can’t propagate this transaction since it will never fit a block which must be at most 4MB.<p><img alt="Groth16 Bitcoin Script" src=https://storopoli.com/blog/bitvm/groth16_block_size.jpg><p>The next step stems from the insight that <strong>to find a fault in a Groth16 proof, we need to find at least one step of the proof verification execution that it fails</strong>. If we find none, then we can be sure that the proof is valid. Maybe we could somehow <strong>split this 1GB huge Bitcoin Script into smaller scripts</strong>, that could be <strong>published in a block</strong> or even <strong>relayed by nodes</strong> if we can get it to fit the standardness requirements<sup class=footnote-reference id=fr-transaction-standardness-2><a href=#fn-transaction-standardness>9</a></sup>.<p>We have merkle trees in the Taproot upgrade, so what if we could split the Groth16 proof verification into a bunch of script spending paths (leaves in the Taproot Merkle tree), then we just need to find at least one leaf that the proof fails. If we cannot find any, then we can be sure that the proof is valid.<p>But, wait! Bitcoin Script is stateless! We cannot pass state from one transaction to the next transaction. Is it? Well, this is the final trick needed to fit the 1GB Groth16 verifier Bitcoin Script into a bunch of standard<sup class=footnote-reference id=fr-transaction-standardness-3><a href=#fn-transaction-standardness>9</a></sup> transactions. We know that Bitcoin Script, despite its limitations, can hash stuff and verify equality. Hence, we need to find a primitive that can carry data with some sort of authentication; and uses exclusively hash functions.<p>This is where <strong>hash-based one-time signatures (OTS)</strong> comes into play. The first, and most famous, OTS is the <strong><a href=https://en.wikipedia.org/wiki/Lamport_signature>Lamport signature</a></strong>, which was invented by <a href=https://en.wikipedia.org/wiki/Leslie_Lamport>Leslie Lamport</a> in 1979. Suppose that what you’re signing is a 256-bit hash $H(m)$ of a message $m$. The way Lamport signatures work is that your public key is the 256 pairs of hashes: 512 in total. The first pair represents all possible <code>0</code>s that a 256-bit hash can have; and the second pair the same for all possible <code>1</code>s. To sign $H(m)$, you just reveal a preimage for each pair depending on the bit of the $H(m)$. Remember that a bit can be only 0 or 1 (a single pair). If your bit index <code>i</code> is <code>0</code> you reveal the preimage for the public key’s first pair at index <code>i</code>, that represents <code>0</code>s; if it’s <code>1</code>, you reveal the preimage for the second pair at index <code>i</code>. This is a one-time signature, since you literally reveal a good chunk of your private key while signing.<p>Below is a visual representation of the Lamport signature. Everything is represented as bits, being either <code>0</code> or <code>1</code>. As you can see, in the top, we have the pair of hashes as public keys, <code>PK1</code> and <code>PK2</code>. In the middle, we have the message that we are signing. Finally, at the bottom, we have the signature which reveals the preimages for the public keys depending on what value of the message for each bit in the message.<p><img alt="Lamport Signature" src=https://storopoli.com/blog/bitvm/lamport_sigs.png><p>Since the Groth16 proof is based mostly on 256-bit group elements, we can <strong>pass the state from one script to the next script by hashing the final state of the computation and continuing in the next script with the hash as the input</strong>. We can avoid tampering since these hashes (the message) are signed. Also, we only need one Lamport public key since it is fine to reuse mostly because the whole batch of transactions will be in the same Taproot Merkle Tree of Scripts. This technique is called <strong>bitcommitments</strong>.<p>The image below shows a P2TR address with a Groth16 verifier in it. All of the scripts inside the Merkle tree of script spending paths are below 400kb, and have a 1,000 stack elements limit. So they adhere to standardness requirements<sup class=footnote-reference id=fr-transaction-standardness-4><a href=#fn-transaction-standardness>9</a></sup>. The first script is the <code>Init</code>: it grabs some inputs from the witness, and performs some computations and results in an output that will be used in the <code>Z_1</code> script. How we pass the state from the <code>Init</code> script to the <code>Z_1</code> script is by using Lamport signatures<sup class=footnote-reference id=fr-winternitz-1><a href=#fn-winternitz>10</a></sup>. From there we keep performing computations and passing the state from <code>Z_2</code> until <code>Z_N</code>. If we get to the last script <code>Z_N</code>, then we just lock it with the prover’s public key so that only him can spend this P2TR address. Each <code>Z_k</code> for any <code>k <= N</code> that uses previous outputs as inputs have a Lamport signature verification procedure in Bitcoin script that if fails will make the script spendable by anyone.<p><img alt="Groth16 Verifier in a P2TR Address" src=https://storopoli.com/blog/bitvm/bitvm_p2tr.svg><p>Remember that all of these scripts are inside a P2TR Merkle tree. Hence unlocking only one of them suffices to spend the whole P2TR UTXO. <strong>If the prover is honest and has a valid proof, then only he can spend the UTXO. However, if the prover is dishonest and has a invalid proof, then anyone can spend the UTXO by simply finding at least one leaf script that the Lamport signature verification fails</strong>.<p>I am not putting the specific opcodes here, because the goal is to give a high-level overview of how we can insert a Groth16 verifier in Bitcoin Script. If you want to learn more about how a ZK-SNARK verifier can be included in a Taproot address, check the <a href=https://bitvm.org/bitvm_bridge.pdf>BitVM2 paper</a>.<h2 id=big-idea-3-emulating-covenants-with-connector-outputs>Big Idea 3: Emulating Covenants with Connector Outputs</h2><p>The next big idea is to <strong>emulate covenants with connector outputs and pre-signed transactions (and timelocks)</strong>. This is not new since the <a href=https://ark-protocol.org/intro/connectors/index.html>Ark protocol already used connectors</a> to emulate covenants.<p>First let’s tackle what are covenants. <strong><a href=https://bitcoinops.org/en/topics/covenants/>Covenants</a></strong> are a category of proposed changes to Bitcoin’s consensus rules that would allow a script to prevent an authorized spender from spending to certain other scripts<sup class=footnote-reference id=fr-timelocks-1><a href=#fn-timelocks>11</a></sup>. A very useful example is the <a href=https://jameso.be/vaults.pdf><code>OP_VAULT</code></a> that allows an UTXO to be only spent to a specific destination. There are many other proposals like this.<p>Ok, but we don’t have covenants in Bitcoin. Hence, we need to <strong>emulate some sort of transaction introspection</strong>. This is where the BitVM bridge comes in: the part of the protocol that creates a <strong>transaction graph made of pre-signed transactions</strong>. These pre-signed transactions are signed by <strong>every operator in the $N$ operators bridge in a way that every operator has his own pre-signed version of the transaction graph by all other operators</strong>. This is important since it allows the <strong>1-of-$N$ trust assumption</strong>, because any operator can use its pre-signed transaction graph to perform a withdraw from the BitVM bridge into Bitcoin.<p>However, only having pre-signed transactions is not enough to emulate covenants. We also need <strong>connector outputs, which are ways to restrict the flow of funds and information in a transaction graph</strong>.<p>To illustrate this, let’s consider a simple toy transaction graph example. In the figure below, we have a transaction graph that has six transactions:<ol><li><strong>Claim</strong><li><strong>Payout Optimistic</strong><li><strong>Challenge</strong><li><strong>Assert</strong><li><strong>Payout</strong><li><strong>Disprove</strong></ol><p><img alt="Transaction Graph" src=https://storopoli.com/blog/bitvm/tx-graph.svg><p>This represents a “contract” between two parties, Alice, the verifier, and Bob, the prover. Alice wants Bob to calculate the <a href=https://en.wikipedia.org/wiki/Pi#Modern_quest_for_more_digits>three-quadrillionth digit of $\pi$</a><sup class=footnote-reference id=fr-pi-1><a href=#fn-pi>12</a></sup>. This can be any computation, but let’s go with a nerdy example, since these are always good mind seeds to sow over the internet. And she’s willing to pay $10$ BTC to Bob if he completes the task, hence she deposits $10$ BTC into a P2TR address. This P2TR address, all the transactions that stems from it, are checked and pre-signed by both Alice and Bob.<p>Let’s follow the flow of transactions. The BTC denomitations are either $10$ BTC to demonstrate the flow of capital, and $\emptyset$ to demonstrate the flow of information. Bob, once ready, can spend Alice’s $10$ BTC using the pre-signed Claim transaction. It has two outputs:<ol><li>A timelocked $10$ BTC output that can be spent using the Payout Optimistic transaction.<li>An empty output $\emptyset$ that can be spent using either the Payout Optimistic transaction or the Challenge transaction.</ol><p>Notice that if Bob is honest and has produced a valid proof, he can just spend both outputs using the Payout Optimistic transaction and wait the timelock to get his $10$ BTC. However, if Bob is dishonest by providing an invalid proof, or even no proof at all, and by trying the Payout Optimistic transaction path, Alice can say “fuck you” and spend the empty output $\emptyset$ using the Challenge transaction. Now the Payout Optimistic transaction is invalid because one of the inputs was spent and no miner would be able to include it in a block.<p>By challenging Bob, Alice also needs to provide funds to cover for the cost of asserting his proof on-chain; say $0.1$ BTC, which is the cost of broadcasting the Assert transaction. Now that Bob was challenged, the only viable path is to assert his proof on-chain using the Assert followed by the Payout path. The Assert transaction carries the $10$ BTC, and inside it we have our Groth16 verifier, denoted as $G16$. $G16$ will verify the proof provided by Bob, using native Bitcoin Script and the big P2TR Merkle tree that we’ve discussed above in <a href=https://storopoli.com/blog/bitvm/#big-idea-2-groth16-bitcoin-script-compiler>Big Idea 2</a>. If the proof is valid, then Bob can spend the $10$ BTC using the Payout transaction that gives him the $10$ BTC back. This has also a timelock to allow Alice to disprove Bob’s proof. If Alice cannot disprove Bob, he will eventually get his $10$ BTC back by the Payout transaction.<p>However, if at least one of the leaves in the big P2TR Merkle tree inside the $G16$ is invalid, then Alice can again say “fuck you” and spend the $10$ BTC using the Disprove transaction that gives her the $10$ BTC back.<p><strong>This is a very clever way to emulate covenant-like behavior using a pre-signed transaction graph that has connector outputs that control the flows of both money and information</strong>.<p>The reader can note that it is trivial to extend this idea to any verified computation, such as “I’ve got the proof that this withdrawal is valid because of some funds in a sidesystem that were burned”. And if the proof is valid, then the operator can have the withdrawal money back to pay the user<sup class=footnote-reference id=fr-withdrawal-1><a href=#fn-withdrawal>13</a></sup>. And <strong>if the proof is invalid, the operator then can have some sort of collateral BTC slashed</strong> with some small part being burned and the <strong>remainder being given to the challenger</strong>. Hence, we have <strong>economic incentives</strong> to make sure that <strong>operators behave</strong> and, not only produce valid proofs, but also <strong>challenge invalid ones</strong>. The whole system also allows for <strong>operators to charge withdrawal fees</strong> from the sidesystem’s users during the withdrawal process.<h2 id=what-can-covenants-bring-to-bitvm>What can covenants bring to BitVM?</h2><p>As I’ve said above, we don’t have covenants yet in Bitcoin<sup class=footnote-reference id=fr-timelocks-2><a href=#fn-timelocks>11</a></sup>. Nevertheless, the future is yet to be written and one day we <strong>might have covenants in Bitcoin</strong>. If, and that’s a big if, we have covenants in Bitcoin, they can bring several benefits to BitVM:<ul><li><strong>The BitVM bridge becomes a <a href=https://petertodd.org/2024/covenant-dependent-layer-2-review>defacto Layer 2</a> for Bitcoin by supporting unilateral trustless withdraws</strong>.<li><strong>The Groth16 verifier might not need to be chunked and split into multiple transactions or locking scripts, and could fit a single transaction</strong>.<li><strong>The sidesystem could be a true ZK-validity rollup, and not a ZK-optimistic rollup</strong>. This allows a much stricter security model for the sidesystem.</ul><p>Let’s dive into the details of how covenants can enhance BitVM.<p>First, with something like <strong><a href=https://bitcoinops.org/en/topics/op_cat/><code>OP_CAT</code></a></strong> and <strong><a href=https://bitcoinops.org/en/topics/op_checktemplateverify/><code>OP_CHECKTEMPLATEVERIFY</code></a></strong>; also known as <code>OP_CTV</code>, we don’t need to have the whole transaction graph pre-signed by every operator. We just need to use <code>OP_CTV</code> with some concatenation using <code>OP_CAT</code> in the transactions to verify important parts of the transactions that guarantee the integrity of the transaction with respect to the BitVM bridge. Then, anyone can do a <strong>unilateral trustless withdraw</strong>, not only a single BitVM operator. This will <strong>turn the BitVM bridge into a <a href=https://petertodd.org/2024/covenant-dependent-layer-2-review>fully trustless Bitcoin Layer 2</a></strong>.<p>Second, using the <strong><a href=https://brink.dev/blog/2024/08/22/eng-call-great-script-restoration/>Great Script Restoration (GSR)</a></strong>, which is a proposal to <strong>bring back all the “dark arts” arithmetic operations as 64-bit arithmetic operations</strong>, like multiplication (<code>OP_MUL</code>), division (<code>OP_DIV</code>), left shift (<code>OP_LSHIFT</code>), and right shift (<code>OP_RSHIFT</code>); we can hugely improve the efficiency of BitVM’s Bitcoin Script-native Groth16 verifier. It may even <strong>fit into a single standard<sup class=footnote-reference id=fr-transaction-standardness-5><a href=#fn-transaction-standardness>9</a></sup> transaction</strong>.<p>Finally, using <strong>both GSR and <code>OP_CAT</code></strong>, we can make the BitVM sidesystem; the thing that we are using the bridge to bridge into from Bitcoin, to <strong><a href=https://ethereum.org/en/developers/docs/scaling/zk-rollups/>become a ZK-validity rollup</a></strong>. This will hugely improve the security model of the BitVM sidesystem, which now, not only inherits the reorg resistance of the Layer 1 blocks, since any rollup derives (and writes) its state into the Layer 1, but also inherits the consensus model of the Layer 1. You cannot <em>opportunistically</em> write the rollup state into Layer 1. It is now fully verified by the Layer 1 consensus. Hence, you don’t need constant “eyes” on the rollup writes in Layer 1 to find frauds, as <strong>the Layer 1 consensus guarantees the validity of the rollup state</strong>.<h2 id=conclusion>Conclusion</h2><p>The focus of this post is to give a high-level overview of BitVM, and building intuitions on how it works. By using the 3 big ideas we can create a very interesting 1-of-$N$ Bitcoin bridge, instead of having to resort to outdated majority federated multisig bridges:<ol><li><strong>Verified Computation</strong><li><strong>Groth16 Bitcoin Script Compiler</strong><li><strong>Emulating Covenants with Connector Outputs</strong></ol><p><strong>This allows all kinds of exciting stuff to be built on top of Bitcoin</strong>. Bitcoin is already the <strong>best money in the world</strong>, being the only <a href=https://bitcoinmagazine.com/culture/history-bitcoin-sound-money-helps-society>“sound money”</a>. However, due to its limited scalability, it is not suitable for wide adoption without either resorting to Layer 2 solutions, or by losing it’s sound money properties by reducing the decentralization<sup class=footnote-reference id=fr-decentralization-1><a href=#fn-decentralization>14</a></sup>. Additionally, Bitcoin is <em>not</em> expressive enough to build interest applications. Things like prediction markets, decentralized exchanges, yield farming, Bitcoin-backed loans, and more have been brought to Bitcoin and left deep traumas. This is due to the fact that, while being possible to build smart contracts that are transparent and can be audited in Ethereum & Co., in Bitcoin they came as a “trust me bro” solutions. All of these usecases cannot be expressed using Bitcoin Script. Hence, you need to fallback to losing custody of funds to use these solutions. Of course, shit hit the fan, and tons of people and companies lost A LOT of money as these “trust me bro” solutions either were hacked or went belly up. This might be a new dawn of BiFi (Bitcoin Finance, and fuck DeFi).<p>Of course, you need a LOT of engineering to implement BitVM. If you are curious about the details, you can check out the <a href=https://github.com/BitVM/BitVM>BitVM repo</a> for the Groth16 compiler, the <a href=https://github.com/alpenlabs/strata-bridge><code>strata-bridge</code></a> repo for the whole BitVM bridge transaction graph; and finally, the <a href=https://github.com/alpenlabs/strata><code>strata</code></a> repo for the Strata rollup (the BitVM sidesystem).<footer class=footnotes><ol class=footnotes-list><li id=fn-peano><p>If you want to dig yourself into a very nice rabbit hole, check <a href=https://en.wikipedia.org/wiki/Peano_axioms>Peano arithmetic</a> and <a href=https://en.wikipedia.org/wiki/Turing_completeness>Turing-completeness relations</a>. <a href=#fr-peano-1>↩</a></p><li id=fn-np-complete><p>Actually, it is any NP-complete problem, but without loss of generality, we’ll focus on NP. <a href=#fr-np-complete-1>↩</a></p><li id=fn-boolean-funs><p>Note that you can represent addition and multiplication as Boolean functions. <a href=#fr-boolean-funs-1>↩</a></p><li id=fn-millennium-problems><p>If you solve this conjecture either by proving it or disproving it, you’ll be up for a <a href=https://en.wikipedia.org/wiki/Millennium_Prize_Problems>1 million USD prize</a>. I like to say that it is the hardest way to earn 1 million USD. <a href=#fr-millennium-problems-1>↩</a></p><li id=fn-negligible><p>A function $f$ is negligible if for every polynomial $p$, there exists an $N$ such that for all $n > N$, $$ f(n) < \frac{1}{p(n)}. $$ If you want to learn more about negligible functions, read Chapter 3, Section 3.1 of the book <a href=https://doi.org/10.1201/9781420010756>Introduction to Modern Cryptography</a> by Katz & Lindell. <a href=#fr-negligible-1>↩</a></p><li id=fn-research><p>Note that ZK-SNARKs and succinct proving systems in general are a very hot research topic. We might find succincter systems in the future. <a href=#fr-research-1>↩</a></p><li id=fn-ceremony><p>In the infamous Zcash setup ceremony, Peter Todd, one of the participants, “ran all of his computations on a laptop encased in a tin foil-lined cardboard box, while driving across Canada. He then burned his compute node to a crisp with a propane torch”. <a href=https://spectrum.ieee.org/the-crazy-security-behind-the-birth-of-zcash>Source</a> <a href=#fr-ceremony-1>↩</a></p><li id=fn-satoshi-commit><p>Check L94-L109 in <code>script.cpp</code> in this <a href=https://github.com/bitcoin/bitcoin/commit/4bd188c4383d6e614e18f79dc337fbabe8464c82>2010 commit</a> from Satoshi. <a href=#fr-satoshi-commit-1>↩</a></p><li id=fn-transaction-standardness><p>Transaction standardness means that a transaction will be accepted by every node in the network. This requires that the transaction is at most 400kvb (that’s kilo “virtual” bytes), and has only one <code>OP_RETURN</code> output with at most 80-bytes of data. If you want to do crazy stuff, like <code>>400kvb</code> or more than one <code>OP_RETURN</code> output, you need to call your friendly neighborhood miner and ask them to include directly into their next block, without having to relay through the Bitcoin network (since no node will accept it). <a href=#fr-transaction-standardness-1>↩</a> <a href=#fr-transaction-standardness-2>↩2</a> <a href=#fr-transaction-standardness-3>↩3</a> <a href=#fr-transaction-standardness-4>↩4</a> <a href=#fr-transaction-standardness-5>↩5</a></p><li id=fn-winternitz><p>Lamport signatures are very inefficient. Teams building BitVM-based bridge generally use <a href=https://asecuritysite.com/encryption/wint>Winternitz signatures</a> instead. <a href=#fr-winternitz-1>↩</a></p><li id=fn-timelocks><p>In a sense absolute and relative timelocks are a sort of covenant. Hence, Bitcoin already has at least one kind of covenant: timelocks. <a href=#fr-timelocks-1>↩</a> <a href=#fr-timelocks-2>↩2</a></p><li id=fn-pi><p>Currently, the record stands at the two-quadrillionth digit. <a href=#fr-pi-1>↩</a></p><li id=fn-withdrawal><p>In the actual BitVM bridge protocol, the operator outfront the withdrawal money to the user with some fee for the service, and then asks for the BitVM bridge for a refund. <a href=#fr-withdrawal-1>↩</a></p><li id=fn-decentralization><p>Decentralization is a key property of Bitcoin, and reducing it would compromise its sound money properties. This is due to the fact that any average Joe can run a node, since the requirements for running a node are minimal: 4MB every 10 minutes. If we increase the block size, or block time, we would increase the cost of running a node, which would reduce decentralization. <a href=#fr-decentralization-1>↩</a></p></ol></footer></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=overlay for=toc-toggle></label><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://storopoli.com/blog/bitvm/#big-idea-1-verified-computation>Big Idea 1: Verified Computation</a><li><a href=https://storopoli.com/blog/bitvm/#big-idea-2-groth16-bitcoin-script-compiler>Big Idea 2: Groth16 Bitcoin Script Compiler</a><li><a href=https://storopoli.com/blog/bitvm/#big-idea-3-emulating-covenants-with-connector-outputs>Big Idea 3: Emulating Covenants with Connector Outputs</a><li><a href=https://storopoli.com/blog/bitvm/#what-can-covenants-bring-to-bitvm>What can covenants bring to BitVM?</a><li><a href=https://storopoli.com/blog/bitvm/#conclusion>Conclusion</a></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><link href=https://storopoli.com/katex.min.css rel=stylesheet><script defer src=https://storopoli.com/js/katex.min.js></script><script defer src=https://storopoli.com/js/mermaid.min.js></script><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://storopoli.com/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://storopoli.com/atom.xml> <img alt=feed loading=lazy src=https://storopoli.com/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=mailto:jose@storopoli.com> <img alt=email loading=lazy src=https://storopoli.com/social_icons/email.svg title=email> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://storopoli.com/publickey.txt> <img alt=pgp loading=lazy src=https://storopoli.com/social_icons/key.svg title=pgp> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/storopoli/> <img alt=github loading=lazy src=https://storopoli.com/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://matrix.to/#/@jose:storopoli.com> <img alt=matrix loading=lazy src=https://storopoli.com/social_icons/matrix.svg title=matrix> </a><li><a class="nav-links no-hover-padding social" href="https://simplex.chat/contact#/?v=2-5&smp=smp%3A%2F%2FUkMFNAXLXeAAe0beCa4w6X_zp18PwxSaSjY17BKUGXQ%3D%40smp12.simplex.im%2FUXrwU_eqdgeHQ6HYehFs0s8VRHOr3k47%23%2F%3Fv%3D1-2%26dh%3DMCowBQYDK2VuAyEApVAYxmE0bpIIiPftNjehy4qOoa14ubyEGzbRX_BlO0w%253D%26srv%3Die42b5weq7zdkghocs3mgxdjeuycheeqqmksntj57rmejagmg4eor5yd.onion" rel=" me"> <img alt=simplex loading=lazy src=https://storopoli.com/social_icons/simplex.svg title=simplex> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://orcid.org/0000-0002-0559-5176> <img alt=orcid loading=lazy src=https://storopoli.com/social_icons/orcid.svg title=orcid> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> • <a href=https://github.com/storopoli/storopoli.com> Site source </a></small></div></section></footer>