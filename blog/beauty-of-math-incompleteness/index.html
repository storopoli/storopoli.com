<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com https://www.youtube.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://storopoli.com name=base><title>
Jose Storopoli, PhD • The beauty of math's incompleteness or how self-references can beautifully screw things up</title><link href=https://storopoli.com/favicon.svg rel=icon type=image/png><link title="Jose Storopoli, PhD - Atom Feed" href=https://storopoli.com/atom.xml rel=alternate type=application/atom+xml><link href="https://storopoli.com/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://storopoli.com/main.css?h=6b1dda977391dad0c76e" rel=stylesheet><link href="https://storopoli.com/extra.css?h=33c2dfb527f758787862" rel=stylesheet><link href="https://storopoli.com/skins/teal.css?h=bd19e558a52d678a50de" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Personal website of Jose Storopoli, PhD" name=description><meta content="Personal website of Jose Storopoli, PhD" property=og:description><meta content="The beauty of math's incompleteness or how self-references can beautifully screw things up" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://storopoli.com/blog/beauty-of-math-incompleteness/ property=og:url><meta content="Jose Storopoli, PhD" property=og:site_name><noscript><link href=https://storopoli.com/no_js.css rel=stylesheet></noscript><script src=https://storopoli.com/js/initializeTheme.min.js></script><script defer src=https://storopoli.com/js/themeSwitcher.min.js></script><body><header><nav class=navbar><div class=nav-title><a class=home-title href=https://storopoli.com>Jose Storopoli, PhD</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://storopoli.com/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://storopoli.com/tags/>tags </a><li class=menu-icons-container><ul class=menu-icons-group><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content><main><article><h1 class=article-title>The beauty of math’s incompleteness or how self-references can beautifully screw things up</h1><ul class=meta><span class="hidden p-author h-card"> <a title="Jose Storopoli, PhD" class=u-url href=https://storopoli.com rel=author>Jose Storopoli, PhD</a> </span><li>24th May 2025<li title="5062 words"><span aria-hidden=true class=separator>•</span>26 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a href=https://storopoli.com/tags/math/>math</a>, <li class=tag><a href=https://storopoli.com/tags/agda/>agda</a></ul><div class=toc-container><h3>Table of Contents</h3><ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#cantor-and-multiple-infinities>Cantor and multiple infinities</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#russell-and-the-barber-paradox>Russell and the barber paradox</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#godel-and-the-incompleteness-theorem>Gödel and the incompleteness theorem</a> <ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#the-first-incompleteness-theorem>The first incompleteness theorem</a> <ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-1-godel-numbering-the-encoding-trick>Step 1: Gödel numbering — the encoding trick</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-2-the-predicate-proves-x-y>Step 2: the predicate “proves(x, y)”</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-3-the-diagonal-lemma-the-self-reference-trick>Step 3: the diagonal lemma — the self-reference trick</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-4-constructing-g-the-godel-sentence>Step 4: constructing $G$ — the Gödel sentence</a></ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#the-second-incompleteness-theorem>The second incompleteness theorem</a> <ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-1-formalizing-consistency>Step 1: formalizing “consistency”</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-2-the-key-connection>Step 2: the key connection</a></ul></ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#turing-and-the-halting-problem>Turing and the halting problem</a> <ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#the-turing-machine>The Turing machine</a></ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#agda-proof-that-the-set-of-real-numbers-is-uncountable>Agda proof that the set of real numbers is uncountable</a> <ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#1-real-number-representation>1. Real number representation</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#2-the-flip-function>2. The flip function</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#3-the-main-theorem>3. The main theorem</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#4-the-diagonal-construction>4. The diagonal construction</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#5-the-proof-of-difference>5. The proof of difference</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#6-the-contradiction>6. The contradiction</a></ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#conclusion>Conclusion</a></ul></div><section class=body><noscript><div class="admonition warning"><div class="admonition-icon admonition-icon-warning"></div><div class=admonition-content><strong class=admonition-title> Evil JavaScript </strong><p>This post uses <a href=https://katex.org/>KaTeX</a> to render mathematical expressions.<p>To see the rendered mathematical expressions, you’ll need to enable JavaScript.</div></div></noscript><p><img alt="A curios mathematician seeing a blackhole of self-referential paradoxes." src=https://storopoli.com/blog/beauty-of-math-incompleteness/self-referential-blackhole.png><blockquote><p>“Logic is the hygiene that the mathematician practises to keep his ideas healthy and strong.”<p>— Hermann Weyl</blockquote><p>I have a very special place for <strong>mathematics in my mind and heart</strong>.<p>Mathematics is above <em>any other science</em>. This is because the knowledge we gather in all other sciences are never <em>absolutely true</em>. All other sciences are based on observations and experiments, and eventually evidence accrues to a threshold that we can morally declare that something is <em>true</em>. Yet, it is not <em>mathematically true</em>, in other words, for any given pile of evidence about a given hypothesis $H$, we have $P(H) < 1$. In a pure philosophical sense, we can never be <em>absolutely sure</em> about scientific hypotheses. There will always be a certain degree of uncertainty even if we have a lot of evidence in favor of a given hypothesis. For mathematical theorems, which is the meat of mathematics, once they are proven, they are <em>absolutely true</em>, i.e. $P(H) = 1$. For example, imagine a galaxy very far away, and a million years from now, given the <a href=https://en.wikipedia.org/wiki/Euclidean_geometry#Axioms>5 axioms of Euclidian geometry</a>, the theorem that the sum of the angles of a triangle is 180 degrees will still be true. It will always be true (given the 5 axioms of course).<p>That is how mathematics won my mind. Now, how it won my heart is a different story. It has to do with the beauty of math’s <em>incompleteness</em>, <em>inconsistency</em>, and <em>undecidability</em>. Which all stems from <strong>self-referential paradoxes</strong>.<h2 id=cantor-and-multiple-infinities>Cantor and multiple infinities</h2><p><img alt="Georg Cantor" src=https://storopoli.com/blog/beauty-of-math-incompleteness/georg-cantor.jpg><p>Let’s go back to 1874, when <a href=https://en.wikipedia.org/wiki/Georg_Cantor>Georg Cantor</a> proved that there are <strong>multiple infinities</strong>. Yes, that sounds crazy, but it is true.<p>Cantor is the father of set theory. Before him, the concept of a set was just a collection of objects and they were all finite collections. This dates back to Aristotle, and no one imagined that there was interesting things to say about sets. In order to put set theory on a solid footing, Cantor had to define what a set is. For finite sets, this was kinda trivial. However, for infinite sets, this is where things started to get interesting.<p>Cantor started exploring the properties of infinite sets. First, he analyzed the properties of the set of natural numbers $\mathbb{N}$. He then realized that the set of natural numbers is the same size as the set of the integers $\mathbb{Z}$ and the set of the rational numbers $\mathbb{Q}$. To show this, he had to come up with a way to compare the sizes of sets. He did this by defining a bijection between the set of natural numbers and the set of integers. A <strong>bijection</strong> is a function that is one-to-one and onto. In other words, it is a function that maps each element of the first set to a unique element of the second set, and each element of the second set to a unique element of the first set.<p>For example, the function<p>$$ f(n) = \begin{cases} -\frac{n}{2} & \text{if } n \text{ is even} \\ \frac{n+1}{2} & \text{if } n \text{ is odd} \end{cases} $$<p>is a bijection between the set of natural numbers and the set of integers.<p>It creates a one-to-one correspondence between the set of natural numbers and the set of integers:<table><thead><tr><th>$f(n)$<th>$\mathbb{N}$<th>$\mathbb{Z}$<tbody><tr><td>f(0)<td>0<td>0<tr><td>f(1)<td>1<td>1<tr><td>f(2)<td>2<td>-1<tr><td>f(3)<td>3<td>2<tr><td>f(4)<td>4<td>-2<tr><td>f(5)<td>5<td>3<tr><td>f(6)<td>6<td>-3</table><p>Ok that was easy, we just proved that the <strong>set of natural numbers and the set of integers have the same size</strong>. Now let’s try to prove the same for the set of rational numbers $\mathbb{Q}$. The idea again is to find a bijection between the set of natural numbers and the set of rational numbers. We can represent the set of rational numbers as a grid of fractions:<p>$$ \begin{array}{cccc} \frac{1}{1} & \quad \frac{1}{2} & \quad \frac{1}{3} & \quad \cdots \\\\ \frac{2}{1} & \quad \frac{2}{2} & \quad \frac{2}{3} & \quad \cdots \\\\ \frac{3}{1} & \quad \frac{3}{2} & \quad \frac{3}{3} & \quad \cdots \\\\ \vdots & \quad \vdots & \quad \vdots & \quad \ddots \\\\ \end{array} $$<p>Now, we can’t just go row by row or column by column — that would never finish the first row! Instead, Cantor had a brilliant idea: traverse the grid diagonally in a zigzag pattern<sup class=footnote-reference id=fr-pairing-function-1><a href=#fn-pairing-function>1</a></sup>.<p>$$ \begin{array}{ccccc} \frac{1}{1} & \rightarrow & \frac{1}{2} & \quad & \frac{1}{3} & \rightarrow & \frac{1}{4} & \cdots \\ & \swarrow & & \nearrow & & \swarrow & \\ \frac{2}{1} & & \frac{2}{2} & & \frac{2}{3} & & \frac{2}{4} & \cdots \\ \downarrow & \nearrow & & \swarrow & & & \\ \frac{3}{1} & & \frac{3}{2} & & \frac{3}{3} & & \frac{3}{4} & \cdots \\ & \swarrow & & \nearrow & & & \\ \frac{4}{1} & & \frac{4}{2} & & \frac{4}{3} & & \frac{4}{4} & \cdots \\ \vdots & & \vdots & & \vdots & & \vdots & \ddots \\ \end{array} $$<p>This gives us the sequence: $$ \frac{1}{1}, \frac{1}{2}, \frac{2}{1}, \frac{3}{1}, \frac{2}{2}, \frac{1}{3}, \frac{1}{4}, \frac{2}{3}, \frac{3}{2}, \frac{4}{1}, \ldots $$<p>But wait! We have a problem — many fractions represent the same rational number:<ul><li>$\frac{2}{2} = \frac{1}{1} = 1$<li>$\frac{2}{4} = \frac{1}{2} = 0.5$</ul><p>To create a true bijection, we need to skip these duplicates. We only keep fractions in <strong>lowest terms</strong>, where $\text{gcd}(\text{numerator}, \text{denominator}) = 1$.<p>After removing duplicates: $$\frac{1}{1}, \frac{1}{2}, \frac{2}{1}, \frac{3}{1}, \frac{1}{3}, \frac{1}{4}, \frac{2}{3}, \frac{3}{2}, \frac{4}{1}, \ldots$$<p>Ok we’re almost there. This is truly a bijection. However, it is a bijection between $\mathbb{N}$ and the set of <em>positive rationals</em>, $\mathbb{Q}^+$. To include all of $\mathbb{Q}$, we interleave <em>positive and negative rationals</em> (and zero). I won’t give the precise mathematical formula here because it is a bit messy, however here’s an algorithm describing the bijection:<ol><li>Start with $n$<li>If $n = 0$, return $0$<li>Otherwise: <ul><li>Let $k = \frac{n+1}{2}$ if $n$ is odd, $k = \frac{n}{2}$ if $n$ is even<li>Find the $k$-th positive rational in our enumeration, call it $r$<li>If $n$ is odd, return $r$<li>If $n$ is even, return $-r$</ul></ol><p>This gives us the following bijection:<table><thead><tr><th>$g(n)$<th>$\mathbb{N}$<th>$\mathbb{Q}^+$ enumeration<th>$\mathbb{Q}$<tbody><tr><td>g(0)<td>0<td>-<td>0<tr><td>g(1)<td>1<td>1st positive: $\frac{1}{1}$<td>1<tr><td>g(2)<td>2<td>1st positive: $\frac{1}{1}$<td>-1<tr><td>g(3)<td>3<td>2nd positive: $\frac{1}{2}$<td>$\frac{1}{2}$<tr><td>g(4)<td>4<td>2nd positive: $\frac{1}{2}$<td>$-\frac{1}{2}$<tr><td>g(5)<td>5<td>3rd positive: $\frac{2}{1}$<td>2<tr><td>g(6)<td>6<td>3rd positive: $\frac{2}{1}$<td>-2</table><p>Q.E.D.! We have a <strong>bijection between $\mathbb{N}$ and $\mathbb{Q}$</strong>.<p>I went over all of these details because this diagonalization argument is a very important insight. Any set that can be put in a one-to-one correspondence with the set of natural numbers is called <strong>countable</strong>. Cantor showed that the set of rational numbers is countable.<p>Let’s see what happens when we try to apply the same argument to the set of real numbers $\mathbb{R}$. For the sake of simplicity, let’s consider the set of real numbers between 0 and 1, $\mathbb{R}_{(0,1)}$.<p>Let’s assume that we have a bijection $f$ between $\mathbb{N}$ and $\mathbb{R}_{(0,1)}$. This would give us the following table:<table><thead><tr><th>$f(n)$<th>$\mathbb{N}$<th>$\mathbb{R}_{(0,1)}$<tbody><tr><td>f(0)<td>0<td>0.011…<tr><td>f(1)<td>1<td>0.111…<tr><td>f(2)<td>2<td>0.112…<tr><td>…<td>…<td>…</table><p>Note that the real number $f(n)$ is the $n$-th real number in the list.<p>Now, let’s construct a new real number $x$ that is not in the list. We will do this by constructing a real number that is different from the $n$-th real number in the list for all $n$. We just add 1 to the $n$-th digit of the $n$-th real number in the list. For example, for the first real number in the list, we add 1 to the first digit, for the second real number in the list, we add 1 to the second digit, and so on.<p>This gives us the following real number: $0.123\ldots$ By construction, this real number is not in the list, since it differs from the first real number in the list by 1 in the first digit, from the second real number in the list by 1 in the second digit, and so on.<p>This is a <strong>contradiction</strong>, since we assumed that $f$ was a bijection.<p>Now, this is where <strong>self-reference</strong> strikes first in this post, and probably in the history of mathematics. When we construct the <em>diagonal number</em> $x$, we’re creating something that:<ol><li>Refers to the entire supposed list of real numbers.<li>Defines itself in opposition to that list — “I differ from the 1st number at position 1, from the 2nd at position 2…”.<li>Uses the list to prove the list is incomplete.</ol><p>Ultimately, this is where Cantor found the first example of a set that is <strong>not countable</strong>. There’s no way to pair the set of natural numbers with the set of real numbers between 0 and 1. Therefore, the set of real numbers between 0 and 1 is <strong>not countable</strong>. This is called the <a href=https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument>Cantor’s diagonal argument</a>.<p>This is a very important insight. It shows that there are <strong>different sizes of infinity</strong>. Yes, that is mind-blowing and paradoxically beautiful.<p>Cantor called the size of the set of natural numbers $\aleph_0$, and conjectured that the set of real numbers is $\aleph_1$. This is called the <a href=https://en.wikipedia.org/wiki/Continuum_hypothesis><strong>continuum hypothesis</strong></a> (CH).<h2 id=russell-and-the-barber-paradox>Russell and the barber paradox</h2><p><img alt="Bertrand Russell" src=https://storopoli.com/blog/beauty-of-math-incompleteness/bertrand-russell.jpg><p>Now let’s fast forward to 1901. Set theory was still in its infancy, yet it was starting to be accepted by the mathematical community. This is where <a href=https://en.wikipedia.org/wiki/Bertrand_Russell>Bertrand Russell</a> after attending the first <a href=https://en.wikipedia.org/wiki/World_Congress_of_Philosophy>World Congress of Philosophy</a> in Paris in 1900, was impressed by the work of Peano who was using set theory to formalize mathematics.<p>He embarked on a journey to <strong>formalize mathematics using set theory</strong>. However, he stumbled upon a <strong>paradox</strong>. Set theory is very lenient with the definition of sets. For example, we can define the set of all sets that are <strong>not members of themselves</strong>:<p>$$ R = \{ x \mid x \notin x \} $$<p>Now what happens if we ask the question: <strong>is $R$ a member of itself?</strong> If $R$ is a member of itself, then it is <em>not</em> a member of itself. If $R$ is <em>not</em> a member of itself, then it is a member of itself.<p>To put more simply, Russell gave the simple analogy: imagine a barber who shaves all men who do not shave themselves. Now, the question is: <strong>does the barber shave himself?</strong> If he does, then he does <em>not</em> shave himself. If he does <em>not</em> shave himself, then he does shave himself.<p>I can even given an even more simple example: the statement “this statement is false” is a paradox. If it is true, then it is false. If it is false, then it is true.<p>Or suppose that I go out and shout out loud: “I am lying”. If I am lying, then I am <em>not</em> lying. If I am <em>not</em> lying, then I am lying.<p>All of these examples boil down to the same thing: we cannot have a set of all sets that are <strong>not members of themselves</strong>.<p>This is called the <a href=https://en.wikipedia.org/wiki/Russell%27s_paradox><strong>Russell’s paradox</strong></a>. And yet again, we have <strong>self-reference</strong> creating a paradox. Personally, I find Cantor’s multiple infinities more beautiful than Russell’s paradox. But I acknowledge that Russell’s paradox is way simpler and more accessible to the general public.<h2 id=godel-and-the-incompleteness-theorem>Gödel and the incompleteness theorem</h2><p><img alt="Kurt Gödel" src=https://storopoli.com/blog/beauty-of-math-incompleteness/kurt-godel.jpg><p>Fasten your seatbelts, this is going to be a wild ride. But first, a little bit of history.<p>In 1900, during the second <a href=https://en.wikipedia.org/wiki/International_Congress_of_Mathematicians>International Congress of Mathematicians</a> in Paris, David Hilbert, arguably the most important mathematician of the 20th century, gave a list of 23 problems that he thought would be the most important to solve in the century. These became known as the <a href=https://en.wikipedia.org/wiki/Hilbert%27s_problems>Hilbert’s problems</a>. Right there in the second problem, Hilbert posed the following problem:<blockquote><p><em>The compatibility of the arithmetical axioms.</em></blockquote><p>Later, Hilbert recasted his “Second Problem” at the eighth <a href=https://en.wikipedia.org/wiki/International_Congress_of_Mathematicians>International Congress of Mathematicians</a> in Bologna. He posed three questions:<ol><li><strong>Was mathematics complete?</strong><li><strong>Was mathematics consistent?</strong><li><strong>Was mathematics decidable?</strong></ol><p>Hilbert believed that mathematics could be put on a completely secure foundation by answering these questions. Gödel would shatter the dream of a <strong>complete and consistent mathematics</strong>. And later, Turing would show that mathematics is <strong>not decidable</strong>.<p>Gödel’s incompleteness theorems<sup class=footnote-reference id=fr-godel-incompleteness-1><a href=#fn-godel-incompleteness>2</a></sup> are composed of two theorems. Let’s start with the first incompleteness theorem, which Gödel proved in 1931 in front of an audience that comprised of no one other than <a href=https://storopoli.com/blog/von-neumann/>Von Neumann</a>, who allegedly was so impressed by Gödel’s work that he remarked:<blockquote><p>It’s all over.</blockquote><h3 id=the-first-incompleteness-theorem>The first incompleteness theorem</h3><p>The First Incompleteness Theorem states:<blockquote><p>For any consistent formal system $F$ that is powerful enough to express basic arithmetic<sup class=footnote-reference id=fr-peano-1><a href=#fn-peano>3</a></sup>, there exists a statement $G$ in the language of $F$ such that:<ol><li>$G$ is true (when interpreted as a statement about natural numbers)<li>$G$ cannot be proven within $F$<li>$\neg G$ (not $G$) cannot be proven within $F$ either</ol></blockquote><p>In other words: <strong>truth and provability are not the same thing</strong>!<p>Gödel’s genius was realizing he could make mathematical statements talk about mathematical statements.<h4 id=step-1-godel-numbering-the-encoding-trick>Step 1: Gödel numbering — the encoding trick</h4><p>Gödel assigned a unique natural number to every mathematical symbol, expression, and proof. Think of it like ASCII encoding for math:<p>Basic symbols get prime numbers:<ul><li><code>0</code> → 2<li><code>=</code> → 3<li><code>+</code> → 5<li><code>(</code> → 7<li><code>)</code> → 11<li>etc.</ul><p>Gödel used a system based on prime factorization. He first assigned a unique natural number to each basic symbol in the formal language of arithmetic with which he was dealing.<p>To encode an entire formula, which is a sequence of symbols, Gödel used the following system. Given a sequence $(x_{1},x_{2},x_{3},…,x_{n})$ of positive integers, the Gödel encoding of the sequence is the product of the first $n$ primes raised to their corresponding values in the sequence For example, the formula $0 = 0$ might become:<ul><li><code>0</code> → 2<li><code>=</code> → 3<li><code>0</code> → 2</ul><p>Gödel number = $2^2 \times 3^3 \times 5^2 = 4 \times 27 \times 25 = 2,700$<p>This is called the <a href=https://en.wikipedia.org/wiki/G%C3%B6del_numbering><strong>Gödel numbering</strong></a>. The key insight is that now <strong>statements about formulas become statements about numbers</strong>!<h4 id=step-2-the-predicate-proves-x-y>Step 2: the predicate “proves(x, y)”</h4><p>Using Gödel numbering, we can write an arithmetic predicate that means: “$x$ is the Gödel number of a proof of the statement with Gödel number $y$”<p>This is purely mechanical — checking if $x$ represents a valid sequence of logical steps ending in $y$.<h4 id=step-3-the-diagonal-lemma-the-self-reference-trick>Step 3: the diagonal lemma — the self-reference trick</h4><p>This is where it gets mind-blowing. Gödel proved:<blockquote><p>For any arithmetic property $P(x)$, we can construct a statement $S$ that says: “$P$ holds for my own Gödel number”</blockquote><p>It’s like writing a sentence that says “This sentence has 25 letters” — but in arithmetic!<p>How the <strong>diagonal lemma</strong> works:<ol><li>Define a function $\text{sub}(n, m) =$ “the result of substituting $m$ into formula $n$”.<li>Consider the property: “The formula with Gödel number $x$, when $x$ substituted into it, has property $P$”.<li>Let this property have Gödel number $d$.<li>Now look at $\text{sub}(d, d)$ — this is $d$ applied to itself.</ol><p>This creates a <strong>fixed point</strong> — a statement that successfully refers to itself.<h4 id=step-4-constructing-g-the-godel-sentence>Step 4: constructing $G$ — the Gödel sentence</h4><p>Using the diagonal lemma with the property “is not provable”, Gödel constructs $G$ such that:<p>$G \iff$ “The statement with Gödel number $g$ is not provable”<p>But $g$ is the Gödel number of $G$ itself! So:<p>$G \iff \text{“$G$ is not provable”}$<p>Now we reason:<p>Case 1: Suppose G is provable:<ul><li>Then G is false (since G says “G is not provable”)<li>So our system proves a false statement<li>The system is inconsistent! ❌</ul><p>Case 2: Suppose $\neg G$ is provable:<ul><li>Then G is true (G really isn’t provable)<li>So $\neg G$ is false<li>Again, the system proves something false<li>Inconsistent! ❌</ul><p>Conclusion: If the system is consistent:<ul><li>Neither $G$ nor $\neg G$ is provable<li>But $G$ is true (it correctly states its own <em>unprovability</em>)<li>We have a true but unprovable statement! ✅</ul><p>This is the <strong>self-reference that Gödel uses to prove his first incompleteness theorem</strong>.<p>The deepest insight is that <strong>self-reference is unavoidable in any system strong enough to do arithmetic</strong>. Once you can:<ol><li><strong>Encode statements as numbers</strong><li><strong>Talk about properties of those numbers</strong><li><strong>Use diagonalization</strong></ol><p>You automatically get statements that assert their own <em>unprovability</em>. Mathematics contains the <strong>seeds of its own incompleteness</strong>!<h3 id=the-second-incompleteness-theorem>The second incompleteness theorem</h3><p>The Second Incompleteness Theorem states:<blockquote><p>If $F$ is a consistent formal system capable of proving basic arithmetic facts, then $F$ cannot prove its own consistency.</blockquote><p>This means <strong>arithmetic cannot prove that arithmetic doesn’t contradict itself</strong>! It’s like a judge who can’t certify their own sanity — the very act of self-certification is suspect.<p>The Second Theorem is actually a clever consequence of the First. Here’s the brilliant insight:<h4 id=step-1-formalizing-consistency>Step 1: formalizing “consistency”</h4><p>First, we need to express “$F$ is consistent” in the language of arithmetic. Gödel realized:<blockquote><p>“$F$ is consistent” $\iff$ “$F$ does not prove both a statement and its negation”</blockquote><p>Using Gödel numbering, this becomes: $\text{Consistency}(F)$ = “There is no statement $A$ such that $F$ proves both $A$ and $\neg A$”<p>Or equivalently: $\text{Consistency}(F)$ = “$F$ does not prove $0=1$” (since from a contradiction, you can prove anything)<h4 id=step-2-the-key-connection>Step 2: the key connection</h4><p>Remember our Gödel sentence $G$ from the First Theorem:<p>$G \iff \text{“$G$ is not provable in $F$”}$<p>Now here’s the brilliant move. Gödel proved that within $F$ itself:<blockquote><p>$F$ can prove: “If $F$ is consistent, then $G$ is not provable”</blockquote><p>Now comes the devastating logic:<ol><li>Assume $F$ can prove its own consistency: $F \vdash \text{Con}(F)$<li>We know $F$ can prove: $\text{Con}(F) \rightarrow G$<li>By deduction: $F \vdash G$<li>But this means $G$ is provable!<li>Since $G$ says “$G$ is not provable”, $G$ must be false<li>So $F$ proves a false statement - $F$ is inconsistent!</ol><p>We’ve shown: <strong>If $F$ can prove its own consistency, then $F$ is inconsistent</strong>!<p>Therefore: <strong>If $F$ is consistent, it cannot prove its own consistency</strong><hr><p>That’s a lot to digest. This is a very deep result that is still being studied today. I find this result to be on par with Cantor’s multiple infinities in beauty. However, Gödel’s incompleteness theorems are a much more outstanding and impressive result.<h2 id=turing-and-the-halting-problem>Turing and the halting problem</h2><p><img alt="Alan Turing" src=https://storopoli.com/blog/beauty-of-math-incompleteness/alan-turing.jpg><p>Hilbert, after being aware of Gödel’s incompleteness theorems, was devastated. His beautiful dream of a complete and consistent mathematics was <strong>shattered</strong>. But there were still hope in the idea of mathematics being decidable.<p>Alan Turing, in 1936, while still an undergraduate at King’s College, Cambridge, published a paper entitled “On Computable Numbers, with an Application to the Entscheidungsproblem”. That mouthful word, <em>Entscheidungsproblem</em>, is the German for what has become known as the <a href=https://en.wikipedia.org/wiki/Halting_problem>“<strong>halting problem</strong>”</a>.<p>The halting problem is the <strong>problem of determining whether a program will halt or run forever</strong>. Turing showed that the halting problem is <strong>undecidable</strong>, thus shattering the last bastion of hope for a complete, consistent, and decidable mathematics.<h3 id=the-turing-machine>The Turing machine</h3><p>To tackle the halting problem, Turing introduced the concept of the <a href=https://en.wikipedia.org/wiki/Turing_machine><strong>Turing machine</strong></a>. A Turing machine is a mathematical model of a computer that can be used to compute anything. It is comprised of a <strong>tape</strong>, a <strong>head</strong>, and a set of <strong>rules</strong>. The tape is infinite in both directions, and is divided into cells. The head can read and write symbols on the tape. The rules are a set of instructions that the head can follow. He showed that any <strong>computable function</strong> can be computed by a Turing machine. I won’t go into much details here, since if you are reading this through the internet, holding on your hands or standing in front of a “Turing machine”, is proof enough that Turing machines can compute stuff.<p>Using the newfound concept of the Turing machine, Turing then redefined the concept of the <strong>halting problem</strong>:<blockquote><p>Given a Turing machine $M$ and input $I$, will $M$ eventually halt (stop) on input $I$, or will it run forever?</blockquote><p>To answer this question, suppose that you have a function that detects if a Turing machine halts on a given input. Here’s how the function signature looks like in Haskell notation:<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-meta z-function z-type-declaration z-haskell"><span class="z-entity z-name z-function z-haskell">halts</span> <span class="z-keyword z-other z-double-colon z-haskell">::</span> <span class="z-storage z-type z-haskell">TuringMachine</span> <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-storage z-type z-haskell">Input</span> <span class="z-keyword z-other z-arrow z-haskell">-></span> <span class="z-storage z-type z-haskell">Bool</span>
</span></span></code></pre><p>This function takes a Turing machine and an input, and returns a boolean value indicating whether the Turing machine halts on the input.<p>Now, let’s say that you have a Turing machine $M$ that uses the <code>halts</code> function to detect whether a Turing machine halts on a given input. However, this machine loops forever if the <code>halts</code> function returns <code>True</code>, or halts if the <code>halts</code> function returns <code>False</code>. This could be expressed in Haskell as:<pre class="language-haskell z-code" data-lang=haskell><code class=language-haskell data-lang=haskell><span class="z-source z-haskell"><span class="z-constant z-other z-haskell">M</span> <span class="z-keyword z-operator z-haskell">::</span> <span class="z-constant z-other z-haskell">TuringMachine</span> <span class="z-keyword z-operator z-haskell">-></span> <span class="z-constant z-other z-haskell">Input</span> <span class="z-keyword z-operator z-haskell">-></span> <span class="z-constant z-language z-unit z-haskell">()</span>
</span><span class="z-source z-haskell"><span class="z-constant z-other z-haskell">M</span> m i <span class="z-keyword z-operator z-haskell">=</span> <span class="z-keyword z-control z-haskell">if</span> halts m i <span class="z-keyword z-control z-haskell">then</span> loop <span class="z-keyword z-control z-haskell">else</span> <span class="z-constant z-language z-unit z-haskell">()</span>
</span></code></pre><p>Now, the question is:<blockquote><p>Does $M$ halt on input $M$?</blockquote><p>If $M$ halts on input $M$, then $M$ loops forever. If $M$ loops forever, then $M$ halts on input $M$.<p>We have arrived at a <strong>contradiction</strong> and the final <strong>self-referential paradox</strong> in this blog post.<p>That’s how Turing, at the young age of 24, proved that <strong>mathematics is <em>not</em> decidable</strong>.<h2 id=agda-proof-that-the-set-of-real-numbers-is-uncountable>Agda proof that the set of real numbers is uncountable</h2><p><a href=https://agda.readthedocs.io/><strong>Agda</strong></a> is a dependently typed programming language. It is often used to prove mathematical theorems. But you can also compile it to Haskell using GHC or to JavaScript using a native compiler. It is like Haskell on steroids, some call it <a href=https://youtu.be/OSDgVxdP20g>“<strong>Super Haskell</strong>”</a>.<p>It follows very closely the <a href=https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence><strong>Curry-Howard correspondence</strong></a>, which is a <strong>magnificent connection between logic and programming</strong>. People also called it “<strong>proof-as-program</strong>” or “<strong>programs-as-proofs</strong>”, since it is a one-to-one correspondence between programs and proofs. The basic idea is that you can write a program that proves a theorem, and the program will type-check if the theorem is true. This is done by having a very powerful and expressive type system, that allows you to express the properties of the objects you are working with. If a type is “inhabited”, it means that there exists a term/value of that type, which under Curry-Howard corresponds to having a proof of the proposition that the type represents.<p>So when a type is “<em>inhabited</em>” in Agda, it means:<ul><li>You can construct a value of that type — there exists some term <code>t : T</code>.<li>The corresponding logical proposition is true/provable.<li>You have evidence/proof of that proposition.</ul><p>Here are some Agda types and their corresponding logical propositions:<ul><li><p><code>⊥</code> (bottom type) is uninhabited — corresponds to <code>False</code> (no proof possible).</p><li><p><code>⊤</code> (unit type) is inhabited by <code>tt</code> — corresponds to trivially <code>True</code>.</p><li><p><code>A → B</code> (implication type) is inhabited by a function — corresponds to <code>A</code> implies <code>B</code> being provable. This is called the <a href=https://agda.readthedocs.io/en/stable/language/function-types.html>Function type</a> in Agda. For example, the type of the addition function for natural numbers is:</p> <pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda">Nat <span class="z-keyword z-other z-agda">→</span> Nat <span class="z-keyword z-other z-agda">→</span> Nat
</span></code></pre><li><p><code>A × B</code> (product type) is inhabited by a pair <code>a , b</code> — corresponds to <code>A</code> and <code>B</code> both being true. For example, the type of a pair of natural numbers is:</p> <pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda">Nat × Nat
</span></code></pre><li><p><code>A ⊎ B</code> (sum type) is inhabited by <code>inj₁ a</code> or <code>inj₂ b</code> — corresponds to <code>A</code> or <code>B</code> being true. Note that <code>⊎</code> is the symbol for disjunction. For example, the type of a natural number or a boolean is:</p> <pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda">Nat ⊎ Bool
</span></code></pre><li><p><code>Σ[ x ∈ A ] B x</code> (dependent sum type) is inhabited by a pair <code>a , b</code> — corresponds to “there exists <code>x : A</code> such that <code>B x</code> is true”. Note that <a href=https://agda.readthedocs.io/en/stable/language/built-ins.html#the-type><code>Σ</code> type</a> is the same as the <a href=https://en.wikipedia.org/wiki/Dependent_type>dependent pair type</a> in type theory. This is more tricky than the product type, because the type of the second component depends on the value of the first component.</p> <p>For example, consider a pair where the first component is a boolean and the second component’s type depends on that boolean:</p> <pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-entity z-name z-agda">BoolDependent</span> <span class="z-keyword z-other z-agda">:</span> Bool <span class="z-keyword z-other z-agda">→</span> <span class="z-constant z-language z-agda">Set</span>
</span><span class="z-source z-agda">BoolDependent true  <span class="z-keyword z-other z-agda">=</span> ℕ      <span class="z-comment z-line z-double-dash z-agda">-- If true, second component is a natural number</span>
</span><span class="z-source z-agda">BoolDependent false <span class="z-keyword z-other z-agda">=</span> String <span class="z-comment z-line z-double-dash z-agda">-- If false, second component is a string</span>
</span><span class="z-source z-agda">
</span><span class="z-source z-agda"><span class="z-comment z-line z-double-dash z-agda">-- The dependent sum type:</span>
</span><span class="z-source z-agda"><span class="z-entity z-name z-agda">BoolDependentPair</span> <span class="z-keyword z-other z-agda">:</span> <span class="z-constant z-language z-agda">Set</span>
</span><span class="z-source z-agda">BoolDependentPair <span class="z-keyword z-other z-agda">=</span> Σ[ b ∈ Bool ] BoolDependent b
</span></code></pre> <p>A value of this type could be <code>true , 42</code> (boolean true paired with natural number 42) or <code>false , "hello"</code> (boolean false paired with string “hello”). The type of the second component depends on the value of the first component.</p><li><p><code>A ≡ B</code> (equality type) is inhabited by a proof of <code>A</code> being equal to <code>B</code> — corresponds to <code>A</code> and <code>B</code> being the same. Note that <code>≡</code> is the symbol for equality.</p> <p>For example, we can prove that <code>2 + 2 ≡ 4</code>:</p> <pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-entity z-name z-agda">proof-2+2=4</span> <span class="z-keyword z-other z-agda">:</span> <span class="z-constant z-numeric z-agda">2</span> + <span class="z-constant z-numeric z-agda">2</span> ≡ <span class="z-constant z-numeric z-agda">4</span>
</span><span class="z-source z-agda">proof-2+2=4 <span class="z-keyword z-other z-agda">=</span> refl
</span></code></pre> <p>Here <code>refl</code> (reflexivity) is the constructor that proves any term is equal to itself. Since <code>2 + 2</code> evaluates to <code>4</code> definitionally in Agda, we can use <code>refl</code> to prove they are equal. The type <code>2 + 2 ≡ 4</code> is inhabited by the proof <code>refl</code>, which serves as evidence that this equality holds.</p></ul><p>To learn Agda, a really nice resource is not only the <a href=https://agda.readthedocs.io/><strong>Agda documentation</strong></a>, but also the <a href=https://leanpub.com/certainty-by-construction><strong>Certainty by Construction: Software and Mathematics in Agda</strong></a> book by Sandy Maguire.<p>I also suggest this quick introduction to Agda:</p><style>.embed-container{max-width:100%;height:0;padding-bottom:56.25%;position:relative;overflow:hidden}.embed-container iframe,.embed-container object,.embed-container embed{width:100%;height:100%;position:absolute;top:0;left:0}</style><div class=embed-container><iframe allowfullscreen frameborder=0 src=https://www.youtube.com/embed/OSDgVxdP20g></iframe></div><p>Now, let’s prove that the <strong>set of real numbers is <em>uncountable</em></strong>. I’m gonna dump the whole Agda code here, then explain the parts that are not obvious. To run the code (which is the same as proving the code or theorem, since the code is the theorem, a.k.a Curry-Howard correspondence), dump the code into a file named <code>CantorDiagonalReals.agda</code>. You can run the code by installing Agda and running <code>agda CantorDiagonalReals.agda</code>. Agda will silently compile the code and if nothing is printed, it means the code (and the theorem) is correct (or true).<pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-keyword z-other z-agda">module</span> <span class="z-entity z-name z-type z-agda">CantorDiagonalReals</span> <span class="z-keyword z-other z-agda">where</span>
</span><span class="z-source z-agda">
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">open import</span> <span class="z-entity z-name z-type z-agda">Data.Nat</span> <span class="z-keyword z-other z-agda">using</span> (ℕ; zero; suc)
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">open import</span> <span class="z-entity z-name z-type z-agda">Data.Bool</span> <span class="z-keyword z-other z-agda">using</span> (Bool; true; false)
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">open import</span> <span class="z-entity z-name z-type z-agda">Data.Empty</span> <span class="z-keyword z-other z-agda">using</span> (⊥)
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">open import</span> <span class="z-entity z-name z-type z-agda">Data.Product</span> <span class="z-keyword z-other z-agda">using</span> (Σ; _,_; _×_; Σ-<span class="z-keyword z-other z-agda">syntax</span>)
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">open import</span> <span class="z-entity z-name z-type z-agda">Relation.Binary.PropositionalEquality</span> <span class="z-keyword z-other z-agda">using</span> (_≡_; refl; cong; trans)
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">open import</span> <span class="z-entity z-name z-type z-agda">Relation.Nullary</span> <span class="z-keyword z-other z-agda">using</span> (¬_)
</span><span class="z-source z-agda">
</span><span class="z-source z-agda"><span class="z-comment z-line z-double-dash z-agda">-- A real number in (0,1) represented as an infinite sequence of binary digits</span>
</span><span class="z-source z-agda"><span class="z-entity z-name z-agda">Real</span> <span class="z-keyword z-other z-agda">:</span> <span class="z-constant z-language z-agda">Set</span>
</span><span class="z-source z-agda">Real <span class="z-keyword z-other z-agda">=</span> ℕ <span class="z-keyword z-other z-agda">→</span> Bool  <span class="z-comment z-line z-double-dash z-agda">-- Each position has a digit 0 or 1</span>
</span><span class="z-source z-agda">
</span><span class="z-source z-agda">
</span><span class="z-source z-agda"><span class="z-comment z-line z-double-dash z-agda">-- Abbreviation for inequality</span>
</span><span class="z-source z-agda"><span class="z-entity z-name z-agda">_≢_</span> <span class="z-keyword z-other z-agda">:</span> {A <span class="z-keyword z-other z-agda">:</span> <span class="z-constant z-language z-agda">Set</span>} <span class="z-keyword z-other z-agda">→</span> A <span class="z-keyword z-other z-agda">→</span> A <span class="z-keyword z-other z-agda">→</span> <span class="z-constant z-language z-agda">Set</span>
</span><span class="z-source z-agda">x ≢ y <span class="z-keyword z-other z-agda">=</span> ¬ (x ≡ y)
</span><span class="z-source z-agda">
</span><span class="z-source z-agda"><span class="z-comment z-line z-double-dash z-agda">-- Helper to flip a bit</span>
</span><span class="z-source z-agda"><span class="z-entity z-name z-agda">flip</span> <span class="z-keyword z-other z-agda">:</span> Bool <span class="z-keyword z-other z-agda">→</span> Bool
</span><span class="z-source z-agda">flip true <span class="z-keyword z-other z-agda">=</span> false
</span><span class="z-source z-agda">flip false <span class="z-keyword z-other z-agda">=</span> true
</span><span class="z-source z-agda">
</span><span class="z-source z-agda"><span class="z-comment z-line z-double-dash z-agda">-- Proof that flip always changes the bit</span>
</span><span class="z-source z-agda"><span class="z-entity z-name z-agda">flip-changes</span> <span class="z-keyword z-other z-agda">:</span> (b <span class="z-keyword z-other z-agda">:</span> Bool) <span class="z-keyword z-other z-agda">→</span> b ≢ flip b
</span><span class="z-source z-agda">flip-changes true ()
</span><span class="z-source z-agda">flip-changes false ()
</span><span class="z-source z-agda">
</span><span class="z-source z-agda"><span class="z-comment z-line z-double-dash z-agda">-- The diagonal argument: no enumeration of reals in (0,1) exists</span>
</span><span class="z-source z-agda"><span class="z-entity z-name z-agda">no-enumeration</span> <span class="z-keyword z-other z-agda">:</span> (f <span class="z-keyword z-other z-agda">:</span> ℕ <span class="z-keyword z-other z-agda">→</span> Real) <span class="z-keyword z-other z-agda">→</span> Σ[ r ∈ Real ] ((n <span class="z-keyword z-other z-agda">:</span> ℕ) <span class="z-keyword z-other z-agda">→</span> f n ≢ r)
</span><span class="z-source z-agda">no-enumeration f <span class="z-keyword z-other z-agda">=</span> diagonal , proof
</span><span class="z-source z-agda">  <span class="z-keyword z-other z-agda">where</span>
</span><span class="z-source z-agda">    <span class="z-comment z-line z-double-dash z-agda">-- Construct the diagonal number by flipping the nth digit of the nth number</span>
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">    </span><span class="z-entity z-name z-agda">diagonal</span> <span class="z-keyword z-other z-agda">:</span> Real
</span><span class="z-source z-agda">    diagonal n <span class="z-keyword z-other z-agda">=</span> flip (f n n)
</span><span class="z-source z-agda">
</span><span class="z-source z-agda">    <span class="z-comment z-line z-double-dash z-agda">-- Proof that diagonal differs from every f n</span>
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">    </span><span class="z-entity z-name z-agda">proof</span> <span class="z-keyword z-other z-agda">:</span> (n <span class="z-keyword z-other z-agda">:</span> ℕ) <span class="z-keyword z-other z-agda">→</span> f n ≢ diagonal
</span><span class="z-source z-agda">    proof n eq <span class="z-keyword z-other z-agda">=</span> contradiction
</span><span class="z-source z-agda">      <span class="z-keyword z-other z-agda">where</span>
</span><span class="z-source z-agda">        <span class="z-comment z-line z-double-dash z-agda">-- If f n = diagonal, then at position n:</span>
</span><span class="z-source z-agda">        <span class="z-comment z-line z-double-dash z-agda">-- (f n n) = (diagonal n) = flip (f n n)</span>
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">        </span><span class="z-entity z-name z-agda">same-at-n</span> <span class="z-keyword z-other z-agda">:</span> f n n ≡ diagonal n
</span><span class="z-source z-agda">        same-at-n <span class="z-keyword z-other z-agda">=</span> cong (<span class="z-keyword z-other z-agda">λ</span> r <span class="z-keyword z-other z-agda">→</span> r n) eq
</span><span class="z-source z-agda">
</span><span class="z-source z-agda">        <span class="z-comment z-line z-double-dash z-agda">-- But diagonal n = flip (f n n) by definition</span>
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">        </span><span class="z-entity z-name z-agda">diagonal-def</span> <span class="z-keyword z-other z-agda">:</span> diagonal n ≡ flip (f n n)
</span><span class="z-source z-agda">        diagonal-def <span class="z-keyword z-other z-agda">=</span> refl
</span><span class="z-source z-agda">
</span><span class="z-source z-agda">        <span class="z-comment z-line z-double-dash z-agda">-- So f n n = flip (f n n)</span>
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">        </span><span class="z-entity z-name z-agda">self-eq-flip</span> <span class="z-keyword z-other z-agda">:</span> f n n ≡ flip (f n n)
</span><span class="z-source z-agda">        self-eq-flip <span class="z-keyword z-other z-agda">=</span> trans same-at-n diagonal-def
</span><span class="z-source z-agda">
</span><span class="z-source z-agda">        <span class="z-comment z-line z-double-dash z-agda">-- This contradicts the fact that flip always changes the bit</span>
</span><span class="z-source z-agda"><span class="z-keyword z-other z-agda">        </span><span class="z-entity z-name z-agda">contradiction</span> <span class="z-keyword z-other z-agda">:</span> ⊥
</span><span class="z-source z-agda">        contradiction <span class="z-keyword z-other z-agda">=</span> flip-changes (f n n) self-eq-flip
</span></code></pre><p>Let’s break down this proof step by step:<h3 id=1-real-number-representation>1. Real number representation</h3><pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-entity z-name z-agda">Real</span> <span class="z-keyword z-other z-agda">:</span> <span class="z-constant z-language z-agda">Set</span>
</span><span class="z-source z-agda">Real <span class="z-keyword z-other z-agda">=</span> ℕ <span class="z-keyword z-other z-agda">→</span> Bool  <span class="z-comment z-line z-double-dash z-agda">-- Each position has a digit 0 or 1</span>
</span></code></pre><p>We represent real numbers in the interval $(0,1)$ as infinite sequences of binary digits. This will make the proof easier to follow without losing any generality. A real number is a function from natural numbers to booleans, where each position gives us a binary digit.<h3 id=2-the-flip-function>2. The flip function</h3><pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-entity z-name z-agda">flip</span> <span class="z-keyword z-other z-agda">:</span> Bool <span class="z-keyword z-other z-agda">→</span> Bool
</span><span class="z-source z-agda">flip true <span class="z-keyword z-other z-agda">=</span> false
</span><span class="z-source z-agda">flip false <span class="z-keyword z-other z-agda">=</span> true
</span><span class="z-source z-agda">
</span><span class="z-source z-agda"><span class="z-entity z-name z-agda">flip-changes</span> <span class="z-keyword z-other z-agda">:</span> (b <span class="z-keyword z-other z-agda">:</span> Bool) <span class="z-keyword z-other z-agda">→</span> b ≢ flip b
</span><span class="z-source z-agda">flip-changes true ()
</span><span class="z-source z-agda">flip-changes false ()
</span></code></pre><p>The <code>flip</code> function switches <code>true</code> to <code>false</code> and vice versa. The <code>flip-changes</code> proof shows that flipping a boolean always produces a different boolean. The <code>()</code> pattern means “impossible case” — there’s no way <code>true ≡ false</code> or <code>false ≡ true</code>. It is called the <a href=https://agda.readthedocs.io/en/stable/language/function-definitions.html#absurd-patterns><strong>absurd pattern</strong></a>.<h3 id=3-the-main-theorem>3. The main theorem</h3><pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-entity z-name z-agda">no-enumeration</span> <span class="z-keyword z-other z-agda">:</span> (f <span class="z-keyword z-other z-agda">:</span> ℕ <span class="z-keyword z-other z-agda">→</span> Real) <span class="z-keyword z-other z-agda">→</span> Σ[ r ∈ Real ] ((n <span class="z-keyword z-other z-agda">:</span> ℕ) <span class="z-keyword z-other z-agda">→</span> f n ≢ r)
</span></code></pre><p>This says: “For any supposed enumeration <code>f</code> of real numbers, there exists a real number <code>r</code> that differs from every number in the enumeration.” This is exactly Cantor’s <strong>diagonalization argument</strong>!<h3 id=4-the-diagonal-construction>4. The diagonal construction</h3><pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-entity z-name z-agda">diagonal</span> <span class="z-keyword z-other z-agda">:</span> Real
</span><span class="z-source z-agda">diagonal n <span class="z-keyword z-other z-agda">=</span> flip (f n n)
</span></code></pre><p>We construct our diagonal number by taking the $n$-th digit of the $n$-th number in the enumeration and flipping it. So <code>diagonal 0 = flip (f 0 0)</code>, <code>diagonal 1 = flip (f 1 1)</code>, etc.<h3 id=5-the-proof-of-difference>5. The proof of difference</h3><pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-entity z-name z-agda">proof</span> <span class="z-keyword z-other z-agda">:</span> (n <span class="z-keyword z-other z-agda">:</span> ℕ) <span class="z-keyword z-other z-agda">→</span> f n ≢ diagonal
</span><span class="z-source z-agda">proof n eq <span class="z-keyword z-other z-agda">=</span> contradiction
</span></code></pre><p>For any number <code>f n</code> in our enumeration, we prove it cannot be equal to our diagonal number. If they were equal (<code>eq : f n ≡ diagonal</code>), we derive a contradiction.<h3 id=6-the-contradiction>6. The contradiction</h3><p>Now let’s examine the contradiction step by step. We assume we have an equality <code>eq : f n ≡ diagonal</code> and derive a contradiction:<pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-entity z-name z-agda">same-at-n</span> <span class="z-keyword z-other z-agda">:</span> f n n ≡ diagonal n
</span><span class="z-source z-agda">same-at-n <span class="z-keyword z-other z-agda">=</span> cong (<span class="z-keyword z-other z-agda">λ</span> r <span class="z-keyword z-other z-agda">→</span> r n) eq
</span></code></pre><p>This uses <strong>congruence</strong> (<code>cong</code>) to say: if two functions are equal (<code>f n ≡ diagonal</code>), then applying them to the same argument (<code>n</code>) gives equal results. So <code>f n n ≡ diagonal n</code>.<p>The <code>λ r → r n</code> is a <strong>lambda function</strong> (anonymous function) that takes a function <code>r</code> and applies it to the argument <code>n</code>. It’s like saying “given any function <code>r</code>, apply it to <code>n</code>”. So <code>cong (λ r → r n) eq</code> means: “if <code>f n ≡ diagonal</code>, then applying the operation “apply to <code>n</code>” to both sides gives <code>f n n ≡ diagonal n</code>“.<pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-entity z-name z-agda">diagonal-def</span> <span class="z-keyword z-other z-agda">:</span> diagonal n ≡ flip (f n n)
</span><span class="z-source z-agda">diagonal-def <span class="z-keyword z-other z-agda">=</span> refl
</span></code></pre><p>This is just the definition of our diagonal function unfolding. Since <code>diagonal n = flip (f n n)</code> by definition, we can prove this equality with <code>refl</code> (reflexivity).<pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-entity z-name z-agda">self-eq-flip</span> <span class="z-keyword z-other z-agda">:</span> f n n ≡ flip (f n n)
</span><span class="z-source z-agda">self-eq-flip <span class="z-keyword z-other z-agda">=</span> trans same-at-n diagonal-def
</span></code></pre><p>Now we chain the equalities using <strong>transitivity</strong> (<code>trans</code>):<ul><li>We know <code>f n n ≡ diagonal n</code> (from <code>same-at-n</code>)<li>We know <code>diagonal n ≡ flip (f n n)</code> (from <code>diagonal-def</code>)<li>Therefore <code>f n n ≡ flip (f n n)</code> (by transitivity)</ul><p>But this is <strong>impossible</strong>! We’re saying a boolean equals its own flip.<pre class="language-agda z-code" data-lang=agda><code class=language-agda data-lang=agda><span class="z-source z-agda"><span class="z-entity z-name z-agda">contradiction</span> <span class="z-keyword z-other z-agda">:</span> ⊥
</span><span class="z-source z-agda">contradiction <span class="z-keyword z-other z-agda">=</span> flip-changes (f n n) self-eq-flip
</span></code></pre><p>Finally, we use our <code>flip-changes</code> lemma, which proves that <code>(b : Bool) → b ≢ flip b</code>. Since we have a proof that <code>f n n ≡ flip (f n n)</code> (which contradicts <code>flip-changes</code>), we can derive the bottom type <code>⊥</code> (which is uninhabited, so it is false/contradiction).<p>This elegant proof captures the essence of Cantor’s diagonalization: <strong>we construct a number that systematically differs from every number in any proposed enumeration, proving that <em>no such enumeration can exist</em></strong>.<h2 id=conclusion>Conclusion</h2><p>I hope you enjoyed this journey into the beauty of mathematics. These self-referential paradoxes underlie the absurd dichotomy of truth and provability, while also revealing the profound beauty of mathematics’ uncomprehensiveness.<p>I often think that mathematics is the language of the universe. Yet, given the incompleteness of mathematics, will it ever be able to describe the universe? Or will the universe be engulfed by a mist of forever unknowable mysteries?<p>Like Hilbert, I am left yelling at the void: <a href=https://en.wikipedia.org/wiki/Ignoramus_et_ignorabimus>“Wir müssen wissen, wir werden wissen.”</a>, which translates to “We must know, we will know.”<footer class=footnotes><ol class=footnotes-list><li id=fn-pairing-function><p>This is called a <a href=https://en.wikipedia.org/wiki/Pairing_function><strong>pairing function</strong></a>, and specifically the <a href=https://en.wikipedia.org/wiki/Cantor_pairing_function><strong>Cantor pairing function</strong></a>. <a href=#fr-pairing-function-1>↩</a></p><li id=fn-godel-incompleteness><p>If you really want to dive deep into the details of Gödel’s incompleteness theorem, check out <a href=https://www.logicmatters.net/igt><strong>Gödel Without (Too Many) Tears</strong></a> by the logician Peter Smith. <a href=#fr-godel-incompleteness-1>↩</a></p><li id=fn-peano><p>Another rabbit hole to dive: <a href=https://en.wikipedia.org/wiki/Peano_arithmetic><strong>Peano’s arithmetic</strong></a>. <a href=#fr-peano-1>↩</a></p></ol></footer></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=overlay for=toc-toggle></label><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#cantor-and-multiple-infinities>Cantor and multiple infinities</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#russell-and-the-barber-paradox>Russell and the barber paradox</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#godel-and-the-incompleteness-theorem>Gödel and the incompleteness theorem</a> <ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#the-first-incompleteness-theorem>The first incompleteness theorem</a> <ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-1-godel-numbering-the-encoding-trick>Step 1: Gödel numbering — the encoding trick</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-2-the-predicate-proves-x-y>Step 2: the predicate “proves(x, y)”</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-3-the-diagonal-lemma-the-self-reference-trick>Step 3: the diagonal lemma — the self-reference trick</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-4-constructing-g-the-godel-sentence>Step 4: constructing $G$ — the Gödel sentence</a></ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#the-second-incompleteness-theorem>The second incompleteness theorem</a> <ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-1-formalizing-consistency>Step 1: formalizing “consistency”</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#step-2-the-key-connection>Step 2: the key connection</a></ul></ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#turing-and-the-halting-problem>Turing and the halting problem</a> <ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#the-turing-machine>The Turing machine</a></ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#agda-proof-that-the-set-of-real-numbers-is-uncountable>Agda proof that the set of real numbers is uncountable</a> <ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#1-real-number-representation>1. Real number representation</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#2-the-flip-function>2. The flip function</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#3-the-main-theorem>3. The main theorem</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#4-the-diagonal-construction>4. The diagonal construction</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#5-the-proof-of-difference>5. The proof of difference</a><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#6-the-contradiction>6. The contradiction</a></ul><li><a href=https://storopoli.com/blog/beauty-of-math-incompleteness/#conclusion>Conclusion</a></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><link href=https://storopoli.com/katex.min.css rel=stylesheet><script defer src=https://storopoli.com/js/katex.min.js></script><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://storopoli.com/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://storopoli.com/atom.xml> <img alt=feed loading=lazy src=https://storopoli.com/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=mailto:jose@storopoli.com> <img alt=email loading=lazy src=https://storopoli.com/social_icons/email.svg title=email> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://storopoli.com/publickey.txt> <img alt=pgp loading=lazy src=https://storopoli.com/social_icons/key.svg title=pgp> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/storopoli/> <img alt=github loading=lazy src=https://storopoli.com/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://matrix.to/#/@jose:storopoli.com> <img alt=matrix loading=lazy src=https://storopoli.com/social_icons/matrix.svg title=matrix> </a><li><a class="nav-links no-hover-padding social" href="https://simplex.chat/contact#/?v=2-5&smp=smp%3A%2F%2FUkMFNAXLXeAAe0beCa4w6X_zp18PwxSaSjY17BKUGXQ%3D%40smp12.simplex.im%2FUXrwU_eqdgeHQ6HYehFs0s8VRHOr3k47%23%2F%3Fv%3D1-2%26dh%3DMCowBQYDK2VuAyEApVAYxmE0bpIIiPftNjehy4qOoa14ubyEGzbRX_BlO0w%253D%26srv%3Die42b5weq7zdkghocs3mgxdjeuycheeqqmksntj57rmejagmg4eor5yd.onion" rel=" me"> <img alt=simplex loading=lazy src=https://storopoli.com/social_icons/simplex.svg title=simplex> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://orcid.org/0000-0002-0559-5176> <img alt=orcid loading=lazy src=https://storopoli.com/social_icons/orcid.svg title=orcid> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> • <a href=https://github.com/storopoli/storopoli.com> Site source </a></small></div></section></footer>