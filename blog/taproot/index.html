<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data: 'self';img-src 'self' https://* data:;media-src 'self';style-src 'self' 'unsafe-inline';frame-src player.vimeo.com https://www.youtube-nocookie.com https://www.youtube.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://storopoli.com name=base><title>
Jose Storopoli, PhD • Merkle trees and the Taproot protocol</title><link href=https://storopoli.com/favicon.svg rel=icon type=image/png><link title="Jose Storopoli, PhD - Atom Feed" href=https://storopoli.com/atom.xml rel=alternate type=application/atom+xml><link href="https://storopoli.com/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://storopoli.com/main.css?h=6b1dda977391dad0c76e" rel=stylesheet><link href="https://storopoli.com/extra.css?h=33c2dfb527f758787862" rel=stylesheet><link href="https://storopoli.com/skins/teal.css?h=bd19e558a52d678a50de" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Personal website of Jose Storopoli, PhD" name=description><meta content="Personal website of Jose Storopoli, PhD" property=og:description><meta content="Merkle trees and the Taproot protocol" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://storopoli.com/blog/taproot/ property=og:url><meta content="Jose Storopoli, PhD" property=og:site_name><noscript><link href=https://storopoli.com/no_js.css rel=stylesheet></noscript><script src=https://storopoli.com/js/initializeTheme.min.js></script><script defer src=https://storopoli.com/js/themeSwitcher.min.js></script><body><header><nav class=navbar><div class=nav-title><a class=home-title href=https://storopoli.com>Jose Storopoli, PhD</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://storopoli.com/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://storopoli.com/tags/>tags </a><li class=menu-icons-container><ul class=menu-icons-group><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content><main><article><h1 class=article-title>Merkle trees and the Taproot protocol</h1><ul class=meta><span class="hidden p-author h-card"> <a title="Jose Storopoli, PhD" class=u-url href=https://storopoli.com rel=author>Jose Storopoli, PhD</a> </span><li>15th Nov 2024<li title="1854 words"><span aria-hidden=true class=separator>•</span>10 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a href=https://storopoli.com/tags/math/>math</a>, <li class=tag><a href=https://storopoli.com/tags/cryptography/>cryptography</a>, <li class=tag><a href=https://storopoli.com/tags/bitcoin/>bitcoin</a></ul><div class=toc-container><h3>Table of Contents</h3><ul><li><a href=https://storopoli.com/blog/taproot/#taproot>Taproot</a><li><a href=https://storopoli.com/blog/taproot/#merkle-trees>Merkle Trees</a> <ul><li><a href=https://storopoli.com/blog/taproot/#merkle-trees-as-commitment-schemes>Merkle Trees as Commitment Schemes</a></ul><li><a href=https://storopoli.com/blog/taproot/#taproot-and-merkle-trees>Taproot and Merkle Trees</a><li><a href=https://storopoli.com/blog/taproot/#why-is-this-useful>Why is this useful?</a><li><a href=https://storopoli.com/blog/taproot/#further-reading>Further Reading</a></ul></div><section class=body><noscript><div class="admonition warning"><div class="admonition-icon admonition-icon-warning"></div><div class=admonition-content><strong class=admonition-title> Evil JavaScript </strong><p>This post uses <a href=https://katex.org/>KaTeX</a> to render mathematical expressions.<p>To see the rendered mathematical expressions, you’ll need to enable JavaScript.</div></div></noscript><noscript><div class="admonition warning"><div class="admonition-icon admonition-icon-warning"></div><div class=admonition-content><strong class=admonition-title> Evil JavaScript </strong><p>This post uses <a href=https://mermaid.js.org>Mermaid</a> to render flowcharts.<p>To see the rendered flowcharts, you’ll need to enable JavaScript.</div></div></noscript><div class="admonition info"><div class="admonition-icon admonition-icon-info"></div><div class=admonition-content><strong class=admonition-title>INFO</strong><p>Dedicated to John Peter, since I was tired of having to explain this to him every time we met.</div></div><p>This post gives an intuition to the <strong>Taproot protocol</strong> in Bitcoin, specifically how <strong>Merkle trees</strong> are used to hide the complexity of several possible spending conditions.<h2 id=taproot>Taproot</h2><p>Taproot was activated as a soft fork in the Bitcoin network on <strong>November 2021</strong>.<p>The <strong>design goals of Taproot</strong> are:<ul><li><strong>Increase privacy</strong>: hide the spending conditions and also hide the fact that you are using a multisig.<li><strong>Reduce the amount of data on-chain</strong>: you only need to commit to the root of a Merkle tree, and not the leaves.<li><strong>Use Schnorr</strong>: Schnorr signatures are more efficient and allow for signature aggregation.</ul><p>My focus is on the middle point: how to use Merkle trees to hide the complexity of the spending conditions. I’m not gonna cover Schnorr signatures here, but you can check <a href=https://conduition.io/cryptography/schnorr/>conduition’s excellent post on Schnorr signatures</a>.<p>So let’s start with Merkle trees.<h2 id=merkle-trees>Merkle Trees</h2><p>A <a href=https://en.wikipedia.org/wiki/Merkle_tree><strong>Merkle tree</strong></a> is a binary tree where the leaves are the data and the internal nodes are the hash of their children. The root of the tree is called the <strong>Merkle root</strong>.<p>Here’s an example:</p><noscript><strong>⚠️ JavaScript is required to render the diagram.</strong></noscript><pre class="mermaid invertible-image">
    flowchart TD
root["root"]
h01["H(0 | 1)"]
h23["H(2 | 3)"]
leaf0["0"]
leaf1["1"]
leaf2["2"]
leaf3["3"]

root --- h01
root --- h23
h01 --- leaf0
h01 --- leaf1
h23 --- leaf2
h23 --- leaf3
</pre><p>In the picture above, the leaves are the numbers 0, 1, 2, and 3. Consider these as data that you want to commit to. We construct the tree by hashing (applying the hash function $H$) the leaves and then concatenating the hashes, and hashing the result until we reach the root.<h3 id=merkle-trees-as-commitment-schemes>Merkle Trees as Commitment Schemes</h3><p>In cryptography, we have something called a <a href=https://en.wikipedia.org/wiki/Commitment_scheme><strong>commitment scheme</strong></a>.<p>A commitment scheme allows you to commit to a value without revealing it. This property is called <strong>hiding</strong>. Commitment schemes are designed so that a party cannot change the value or statement after they have committed to it. This property is called <strong>binding</strong>.<p>The classical example is a <strong>hash function</strong>. Say you have a value $x$ and you want to commit to it. You can hash $x$ and send the hash to the other party. In the future, you can reveal $x$ and the other party can hash it and check if it matches the hash you sent.<p>This is a commitment scheme because you cannot know the value of $x$ by looking at the hash. Hence, it is hiding. And you cannot change the value of $x$ without changing the hash, hence it is binding.<p>However, this is a commitment scheme for a single value. What if you have multiple values you want to commit to? This is where Merkle trees come in.<p><strong>Merkle trees are commitment schemes</strong>. You commit to the root of the tree, and you can prove that a leaf is in the tree by revealing the path from the leaf to the root.<p>It is hiding because you cannot know the value of a leaf by looking at the root. And it is binding because you cannot change the value of a leaf without changing the root.<p>Note that the inclusion proof is logarithmic in the number of leaves, hence the complexity of the inclusion proof is $O(\log n)$, where $n$ is the number of leaves, or the depth of the desired leaf in the tree. This makes Merkle trees a very efficient commitment scheme.<h2 id=taproot-and-merkle-trees>Taproot and Merkle Trees</h2><p>Now that we understand Merkle trees, let’s see how they are used in Taproot. The anatomy of a <strong>Pay-to-Taproot (P2TR) address</strong> is as follows:<ol><li><strong>Internal key</strong>: the public key of the owner.<li><strong>Merkle root</strong>: the root of the Merkle tree of spending conditions.</ol><p>These are also called the <strong>key path</strong> and the <strong>script path</strong>, respectively. You can find more about the Taproot soft fork in the <a href=https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki>BIP 341</a> that describes Taproot spending rules.<div class="admonition info"><div class="admonition-icon admonition-icon-info"></div><div class=admonition-content><strong class=admonition-title>INFO</strong><p>Note that there are ways to tweak the internal key that I will not cover here for simplicity. They are mainly used to disable the key path in a verifiable way and force the spending to only use script path conditions. Again, check <a href=https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki>BIP 341</a> for more details.</div></div><p>Here’s an example of a Taproot address:</p><noscript><strong>⚠️ JavaScript is required to render the diagram.</strong></noscript><pre class="mermaid invertible-image">
    flowchart TD
p2tr["P2TR"]
internal["Internal Key"]
merkle["Root of the Merkle Tree"]
s1["S1"]
node["Node"]
s2["S2"]
s3["S3"]

p2tr --- internal
p2tr --- merkle
merkle --- s1
merkle --- node
node --- s2
node --- s3
</pre><p>Here we can see that we have the internal key and the root of the Merkle tree. The internal key is the key path, and the Merkle tree is the script path. If you want to spend from this address, you can either use the internal key or any of the spending conditions $S_n$ that are leaves in the Merkle tree.<p>Let’s focus in the spending conditions $S_n$. We have 3 conditions in the example above. These are vanilla Pay-to-(Witness)-Script-Hash P2SH scripts, so you can have multisig, timelocks, etc. in these conditions. P2SH scripts are not immediately revealed on-chain, you just commit to the hash of the script. They are only revealed when you spend from the address, where you need to reveal the script and Bitcoin consensus will not only check if the script is correct, but also that it matches the hash committed.<div class="admonition info"><div class="admonition-icon admonition-icon-info"></div><div class=admonition-content><strong class=admonition-title>INFO</strong><p>Yes, P2SH is a commitment scheme. It is hiding because you cannot know the script by looking at the hash. And it is binding because you cannot change the script without changing the hash.</div></div><p>In a Merkle tree, it takes $O(\log n)$ space to prove inclusion, where $n$ is the depth of the leaf that we want to prove, we order the leaves in the tree in such a way that the most likely conditions are closer to the root.<p>In this case we have $S_1$ as the most likely condition, and $S_2$ and $S_3$ as less likely conditions.<p>Suppose you want to spend from the address using $S_2$. How would you prove that $S_2$ is in the tree? Well, you need to reveal the path from $S_2$ to the root. This entails revealing the hash of the sibling of $S_2$, that is the hash of $S_3$, Ok now we got the “Node” in the picture above, but we still need to reveal the hash of the sibling of “Node”, that is $S_1$. This is enough to prove that $S_2$ is in the tree. See that we had to reveal the hashes of $S_1$ and $S_3$, since $S_2$ has depth $n = 3$ in the tree it took $\lceil O(\log 3) \rceil = 2$ steps to prove inclusion.<p>Now, suppose you want to spend from the address using $S_1$. Same thing, you need to reveal the path from $S_1$ to the root. This is easily done with just revealing the hash of “Node”. So a single operation is enough to prove inclusion. This is due to the fact that $S_1$ has depth $n = 2$ in the tree, hence it took $\lceil O(\log 2) \rceil = 1$ step to prove inclusion.<p>This is the beauty of Merkle trees.<p>Contrast this with other script addresses formats such as P2SH. In P2SH, you are only tied to a single script. You could have a bunch of nested IFs in the script, to emulate the same behavior as the Merkle tree, but good luck paying the fees for that monstrous script when you want to spend from the address.<h2 id=why-is-this-useful>Why is this useful?</h2><p>I work at <a href=https://alpenlabs.io/>Alpen Labs</a>, where we are developing <a href=https://stratabtc.org>Strata</a>, a <a href=https://bitvm.org/>BitVM</a>-based bridge for Bitcoin. To put it simply, BitVM is a computing paradigm to express Turing-complete Bitcoin contracts.<p>BitVM was only possible due to the Taproot soft fork. Before we dive into details, just one minor detail about Merkle trees in Taproot: they can have a maximum depth of 128. This means that you can have up to $2^{128}$ spending conditions. And each of this spending conditions is a script that follows the Bitcoin consensus rules. Mostly important of these is that the transaction size must be less than 4MB. So, you can have a Taproot address that encodes a Turing-complete contract with up to $2^{128}$ clauses. And each of these clauses can be a complex script up to 4MB in size. Hence, we can hide the complexity of a Turing-complete contract in a single Taproot address. This allows us to encode $2^{128} \cdot 4\text{MB}$ of data which is more than the <strong>estimated data content of the surface web</strong>, according to <a href="https://www.wolframalpha.com/input?i=2%5E128+*+4mb">wolframalpha</a>.<p>More specifically, we can encode a gigabyte-sized <a href=https://eprint.iacr.org/2016/260>Groth16</a> verifier in Bitcoin script as a Taproot address by splitting the execution of the verifier into 4MB chunks and encoding each chunk as a spending condition as a leaf in a Taproot Merkle tree. And we can pass state between these chunks by using one-time signatures, such as <a href=https://en.wikipedia.org/wiki/Lamport_signature>Lamport Signatures</a>. This involves encoding all the elliptic curve operations and pairings required by the Groth16 verifier along with a way to express Lamport signature verification in Bitcoin script. But this is a topic for a future post.<blockquote><p><a href="https://storopoli.com/blog/taproot/$block.attrs('info')"></a> If you want to know more about how to encode a Groth16 verifier using Bitcoin script, check the <a href=https://www.alpenlabs.io/blog/state-of-snark-verification-with-bitvm2>Alpen Labs blog</a>.</blockquote><h2 id=further-reading>Further Reading</h2><p>The idea behind this post is to give an intuition to the Taproot protocol and how Merkle trees are used to hide the complexity of the spending conditions. There is a bunch of technical details that I left out for simplicity. Please go over the <a href=https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki>BIP 341</a> to check all the technicalities of Taproot, such as the different ways to tweak the internal key, tagged hashes, and Taproot annexes.<div class="admonition info"><div class="admonition-icon admonition-icon-info"></div><div class=admonition-content><strong class=admonition-title>INFO</strong><p>I would also recommend <a href=https://base58.school/classes/taproot>base58’s workshop on Taproot</a>.</div></div><p>Merkle trees were introduced by Ralph Merkle in 1979. If you want to know more about Merkle trees, check <a href=https://toc.cryptobook.us/>Section 8.9 of Dan Boneh’s textbook “A Graduate Course in Applied Cryptography”</a>. They are used in many applications in computer science, for example file systems use Merkle trees to verify the integrity of files. Another example is the Nix package manager, which uses Merkle trees to ensure reproducibility of builds.<p>There are many variations of Merkle trees, for example Etereum uses a Patricia Merkle tree, a combination of a Merkle tree and a <a href=https://en.wikipedia.org/wiki/Patricia_trie>Patricia trie</a>, which is a <a href=https://en.wikipedia.org/wiki/Trie>“Merkle” trie</a> where the keys are hashed.</section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=overlay for=toc-toggle></label><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://storopoli.com/blog/taproot/#taproot>Taproot</a><li><a href=https://storopoli.com/blog/taproot/#merkle-trees>Merkle Trees</a> <ul><li><a href=https://storopoli.com/blog/taproot/#merkle-trees-as-commitment-schemes>Merkle Trees as Commitment Schemes</a></ul><li><a href=https://storopoli.com/blog/taproot/#taproot-and-merkle-trees>Taproot and Merkle Trees</a><li><a href=https://storopoli.com/blog/taproot/#why-is-this-useful>Why is this useful?</a><li><a href=https://storopoli.com/blog/taproot/#further-reading>Further Reading</a></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><link href=https://storopoli.com/katex.min.css rel=stylesheet><script defer src=https://storopoli.com/js/katex.min.js></script><script defer src=https://storopoli.com/js/mermaid.min.js></script><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://storopoli.com/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://storopoli.com/atom.xml> <img alt=feed loading=lazy src=https://storopoli.com/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=mailto:jose@storopoli.com> <img alt=email loading=lazy src=https://storopoli.com/social_icons/email.svg title=email> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://storopoli.com/publickey.txt> <img alt=pgp loading=lazy src=https://storopoli.com/social_icons/key.svg title=pgp> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/storopoli/> <img alt=github loading=lazy src=https://storopoli.com/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://matrix.to/#/@jose:storopoli.com> <img alt=matrix loading=lazy src=https://storopoli.com/social_icons/matrix.svg title=matrix> </a><li><a class="nav-links no-hover-padding social" href="https://simplex.chat/contact#/?v=2-5&smp=smp%3A%2F%2FUkMFNAXLXeAAe0beCa4w6X_zp18PwxSaSjY17BKUGXQ%3D%40smp12.simplex.im%2FUXrwU_eqdgeHQ6HYehFs0s8VRHOr3k47%23%2F%3Fv%3D1-2%26dh%3DMCowBQYDK2VuAyEApVAYxmE0bpIIiPftNjehy4qOoa14ubyEGzbRX_BlO0w%253D%26srv%3Die42b5weq7zdkghocs3mgxdjeuycheeqqmksntj57rmejagmg4eor5yd.onion" rel=" me"> <img alt=simplex loading=lazy src=https://storopoli.com/social_icons/simplex.svg title=simplex> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://orcid.org/0000-0002-0559-5176> <img alt=orcid loading=lazy src=https://storopoli.com/social_icons/orcid.svg title=orcid> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> • <a href=https://github.com/storopoli/storopoli.com> Site source </a></small></div></section></footer>